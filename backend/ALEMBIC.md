# Alembic Migrations Guide

## Quick Reference

### Full Database Setup (New Database)
```bash
cd backend

# 1. Run Alembic migrations
SECRET_KEY='your-key' DATABASE_URL=sqlite:///./data/idees_montreal.db uv run python -m scripts.migrate upgrade head

# 2. Seed initial data (categories, admin user)
SECRET_KEY='your-key' DATABASE_URL=sqlite:///./data/idees_montreal.db uv run python init_db.py

# 3. Set up FTS5 full-text search (SQLite only)
SECRET_KEY='your-key' DATABASE_URL=sqlite:///./data/idees_montreal.db uv run python migrations/sqlite_fts5_setup.py

# 4. Verify search index
SECRET_KEY='your-key' DATABASE_URL=sqlite:///./data/idees_montreal.db uv run python -m scripts.optimize_search_indexes --analyze
```

### Common Commands
```bash
# Apply all pending migrations
uv run python -m scripts.migrate upgrade head

# Rollback one migration
uv run python -m scripts.migrate downgrade -1

# Create new migration after model changes
uv run alembic revision --autogenerate -m "describe change"

# Check current migration version
sqlite3 ./data/idees_montreal.db "SELECT * FROM alembic_version;"
```

---

## Overview

This project uses **Alembic** for database schema migrations. Key files:

| File | Purpose |
|------|---------|
| `alembic.ini` | Alembic configuration |
| `alembic/env.py` | Imports app metadata for autogeneration |
| `alembic/versions/` | Migration scripts |
| `scripts/migrate.py` | CLI wrapper for deployment scripts |
| `migrations/sqlite_fts5_setup.py` | FTS5 full-text search setup (SQLite) |
| `scripts/optimize_search_indexes.py` | Search index maintenance |

---

## When to Use Alembic

### Use Alembic When:
- Adding/removing columns from tables
- Creating new tables
- Modifying column types or constraints
- Adding/removing indexes
- Any schema change that affects `db_models.py`

### Don't Use Alembic For:
- FTS5 virtual tables (use `migrations/sqlite_fts5_setup.py`)
- Initial data seeding (use `init_db.py`)
- Search index rebuilding (use `scripts/optimize_search_indexes.py`)

---

## Migration Workflow

### 1. Making Model Changes

After modifying `backend/repositories/db_models.py`:

```bash
cd backend

# Generate migration automatically
uv run alembic revision --autogenerate -m "add user preferences table"

# Review the generated file in alembic/versions/
# ALWAYS review autogenerated migrations before applying!
```

### 2. Reviewing Migrations

Autogenerate is helpful but imperfect. Always check:
- Column types match your intent
- Foreign keys are correct
- Indexes are included
- Data migrations are handled (autogenerate doesn't do this)

### 3. Applying Migrations

```bash
# Development - apply directly
uv run python -m scripts.migrate upgrade head

# Production - always backup first!
cp ./data/idees_montreal.db ./data/idees_montreal.db.bak
uv run python -m scripts.migrate upgrade head
```

### 4. Rolling Back

```bash
# Rollback one step
uv run python -m scripts.migrate downgrade -1

# Rollback to specific revision
uv run python -m scripts.migrate downgrade abc123
```

---

## Current Migrations

| Revision | Description |
|----------|-------------|
| `0001_initial` | Creates all tables from SQLAlchemy models |
| `87d33473f8b1` | Adds indexes, NOT NULL constraints, FK fixes |

---

## SQLite + FTS5 Considerations

SQLite with FTS5 requires special handling because:
1. FTS5 virtual tables are not managed by Alembic
2. FTS triggers can interfere with table alterations
3. Alembic's batch mode may leave temp tables on failure

### Safe Migration Workflow for SQLite + FTS

**Option A: Test on Fresh Database (Recommended)**
```bash
# Create test database
SECRET_KEY='test-key' DATABASE_URL=sqlite:///./data/test.db uv run python -m scripts.migrate upgrade head
SECRET_KEY='test-key' DATABASE_URL=sqlite:///./data/test.db uv run python init_db.py
SECRET_KEY='test-key' DATABASE_URL=sqlite:///./data/test.db uv run python migrations/sqlite_fts5_setup.py

# Verify it works, then apply to production
```

**Option B: In-Place Migration (Production)**
```bash
# 1. Backup
cp ./data/idees_montreal.db ./data/idees_montreal.db.bak

# 2. Drop FTS (optional, if migration touches ideas table)
sqlite3 ./data/idees_montreal.db "DROP TRIGGER IF EXISTS ideas_fts_insert;"
sqlite3 ./data/idees_montreal.db "DROP TRIGGER IF EXISTS ideas_fts_update;"
sqlite3 ./data/idees_montreal.db "DROP TRIGGER IF EXISTS ideas_fts_delete;"
sqlite3 ./data/idees_montreal.db "DROP TRIGGER IF EXISTS idea_tags_insert_fts;"
sqlite3 ./data/idees_montreal.db "DROP TRIGGER IF EXISTS idea_tags_delete_fts;"
sqlite3 ./data/idees_montreal.db "DROP TABLE IF EXISTS ideas_fts;"

# 3. Run migration
uv run python -m scripts.migrate upgrade head

# 4. Recreate FTS
uv run python migrations/sqlite_fts5_setup.py

# 5. Verify
uv run python -m scripts.optimize_search_indexes --analyze
```

---

## Troubleshooting

### Problem: "vtable constructor failed: ideas_fts"

The FTS5 virtual table is corrupted or incompatible.

**Solution:**
```bash
# Drop and recreate FTS
sqlite3 ./data/idees_montreal.db "DROP TABLE IF EXISTS ideas_fts;"
uv run python migrations/sqlite_fts5_setup.py
uv run python -m scripts.optimize_search_indexes --rebuild
```

### Problem: Leftover `_alembic_tmp_*` Tables

Alembic's batch mode failed mid-operation.

**Solution:**
```bash
# Check for temp tables
sqlite3 ./data/idees_montreal.db "SELECT name FROM sqlite_master WHERE name LIKE '_alembic_tmp%';"

# If found, either rename back or drop (depending on state)
sqlite3 ./data/idees_montreal.db "DROP TABLE IF EXISTS _alembic_tmp_tablename;"

# Then retry migration
```

### Problem: Migration Fails Due to Triggers

FTS triggers reference tables being modified.

**Solution:** Follow "Option B" above - drop triggers before migration, recreate after.

### Problem: "Column already exists" or Similar

Migration was partially applied or schema is out of sync.

**Solution:**
```bash
# Check current version
sqlite3 ./data/idees_montreal.db "SELECT * FROM alembic_version;"

# If needed, manually set version (use with caution!)
sqlite3 ./data/idees_montreal.db "UPDATE alembic_version SET version_num='target_version';"
```

---

## Best Practices

1. **Always backup before production migrations**
   ```bash
   cp ./data/idees_montreal.db ./data/idees_montreal.db.$(date +%Y%m%d_%H%M%S).bak
   ```

2. **Test migrations on a copy first**
   ```bash
   cp ./data/idees_montreal.db ./data/test_migration.db
   DATABASE_URL=sqlite:///./data/test_migration.db uv run python -m scripts.migrate upgrade head
   ```

3. **Keep migrations small and focused** - One logical change per migration

4. **Review autogenerated migrations** - They may miss data migrations or have incorrect operations

5. **Add comments to migrations** - Explain any guarded or conditional logic

6. **Use the wrapper script** - `python -m scripts.migrate` works without alembic CLI installed

---

## CI Integration

Add to your CI pipeline:
```yaml
# Example GitHub Actions step
- name: Test Migrations
  run: |
    cd backend
    SECRET_KEY='ci-test-key' DATABASE_URL=sqlite:///./data/ci_test.db uv run python -m scripts.migrate upgrade head
    SECRET_KEY='ci-test-key' DATABASE_URL=sqlite:///./data/ci_test.db uv run python init_db.py
    SECRET_KEY='ci-test-key' DATABASE_URL=sqlite:///./data/ci_test.db uv run python migrations/sqlite_fts5_setup.py
    SECRET_KEY='ci-test-key' DATABASE_URL=sqlite:///./data/ci_test.db uv run python -m scripts.optimize_search_indexes --analyze
```

---

## PostgreSQL Notes

For PostgreSQL deployments:
- FTS uses built-in `tsvector` columns (no separate virtual tables)
- Use `migrations/postgresql_fts_setup.py` instead of SQLite FTS5 setup
- Standard Alembic workflow applies without FTS complications
