#!/usr/bin/env python3
"""
CVE Prioritization Engine.

Combines multiple factors to prioritize vulnerabilities:
- CVSS score (base severity)
- Exploitability (known public exploits)
- Applicability (is the vulnerable component actually in use)
- Fix availability (can it be patched easily)

Usage:
    SCAN_DIR=/app/results/cve python prioritize_cves.py
"""

import json
import os
from pathlib import Path
from typing import Dict, List, Any
from datetime import datetime
from dataclasses import dataclass, asdict

SCAN_DIR = os.environ.get("SCAN_DIR", "/app/results/cve")


@dataclass
class PrioritizedCVE:
    cve_id: str
    priority_score: float
    priority_tier: str  # CRITICAL, HIGH, MEDIUM, LOW
    cvss_score: float
    cvss_severity: str
    has_exploit: bool
    exploit_count: int
    affected_packages: List[str]
    is_fixable: bool
    fix_version: str
    reason: str


class CVEPrioritizer:
    def __init__(self):
        self.scan_dir = Path(SCAN_DIR)
        self.nvd_data = {}
        self.exploit_data = {}
        self.package_data = []

    def load_data(self):
        """Load all CVE data from previous phases."""
        # Load NVD correlation
        nvd_file = self.scan_dir / "nvd_correlation.json"
        if nvd_file.exists():
            try:
                with open(nvd_file, "r") as f:
                    data = json.load(f)
                    for cve in data.get("cves", []):
                        self.nvd_data[cve["id"]] = cve
            except Exception as e:
                print(f"[!] Error loading NVD data: {e}")

        # Load Exploit-DB results
        exploit_file = self.scan_dir / "exploitdb_results.json"
        if exploit_file.exists():
            try:
                with open(exploit_file, "r") as f:
                    data = json.load(f)

                    # Track exploitable CVEs
                    for cve_id in data.get("exploitable_cve_list", []):
                        self.exploit_data[cve_id] = 1

                    # Count exploits per CVE
                    for exploit in data.get("exploits_by_cve", []):
                        cve_id = exploit.get("cve_id")
                        if cve_id:
                            self.exploit_data[cve_id] = self.exploit_data.get(cve_id, 0) + 1

            except Exception as e:
                print(f"[!] Error loading exploit data: {e}")

        # Load package data from scans
        self._load_package_data()

    def _load_package_data(self):
        """Extract package vulnerability data from scan results."""
        # Parse Trivy results
        for trivy_file in self.scan_dir.glob("**/trivy-*.json"):
            try:
                with open(trivy_file, "r") as f:
                    data = json.load(f)

                for result in data.get("Results", []):
                    for vuln in result.get("Vulnerabilities", []):
                        self.package_data.append({
                            "cve_id": vuln.get("VulnerabilityID", ""),
                            "package": vuln.get("PkgName", ""),
                            "installed_version": vuln.get("InstalledVersion", ""),
                            "fixed_version": vuln.get("FixedVersion", ""),
                            "severity": vuln.get("Severity", ""),
                            "source": trivy_file.name
                        })
            except Exception:
                pass

        # Parse Grype results
        for grype_file in self.scan_dir.glob("**/grype-*.json"):
            try:
                with open(grype_file, "r") as f:
                    data = json.load(f)

                for match in data.get("matches", []):
                    artifact = match.get("artifact", {})
                    vuln = match.get("vulnerability", {})
                    fix = vuln.get("fix", {})

                    fix_versions = fix.get("versions", [])
                    fixed_version = fix_versions[0] if fix_versions else ""

                    self.package_data.append({
                        "cve_id": vuln.get("id", ""),
                        "package": artifact.get("name", ""),
                        "installed_version": artifact.get("version", ""),
                        "fixed_version": fixed_version,
                        "severity": vuln.get("severity", ""),
                        "source": grype_file.name
                    })
            except Exception:
                pass

    def calculate_priority(self, cve_id: str) -> PrioritizedCVE:
        """Calculate priority score for a CVE."""
        nvd = self.nvd_data.get(cve_id, {})
        cvss = nvd.get("cvss", {})
        cvss_score = cvss.get("score", 0)
        cvss_severity = cvss.get("severity", "UNKNOWN")

        # Get exploit info
        exploit_count = self.exploit_data.get(cve_id, 0)
        has_exploit = exploit_count > 0

        # Get affected packages
        affected = [p for p in self.package_data if p["cve_id"] == cve_id]
        affected_packages = list(set([p["package"] for p in affected if p["package"]]))

        # Determine if fixable
        fixed_versions = [p["fixed_version"] for p in affected if p["fixed_version"]]
        is_fixable = len(fixed_versions) > 0
        fix_version = fixed_versions[0] if fixed_versions else ""

        # Calculate priority score (0-100)
        # Base: CVSS score * 10 (0-100)
        priority_score = cvss_score * 10

        # Exploit bonus: +20 if exploit exists
        if has_exploit:
            priority_score += 20
            # Additional +5 per extra exploit (max +15)
            priority_score += min(15, (exploit_count - 1) * 5)

        # Applicability: more affected packages = higher priority
        priority_score += min(10, len(affected_packages) * 2)

        # Fix penalty: -5 if no fix available (focus on fixable first)
        # Actually, no fix might mean it's more concerning, but we want actionable items first
        if not is_fixable:
            priority_score -= 5

        # Cap at 100
        priority_score = min(100, max(0, priority_score))

        # Determine tier
        if priority_score >= 85 or (cvss_score >= 9.0 and has_exploit):
            priority_tier = "CRITICAL"
        elif priority_score >= 70 or cvss_score >= 7.0:
            priority_tier = "HIGH"
        elif priority_score >= 50 or cvss_score >= 4.0:
            priority_tier = "MEDIUM"
        else:
            priority_tier = "LOW"

        # Build reason
        reasons = []
        if cvss_score >= 9.0:
            reasons.append(f"Critical CVSS ({cvss_score})")
        elif cvss_score >= 7.0:
            reasons.append(f"High CVSS ({cvss_score})")
        elif cvss_score >= 4.0:
            reasons.append(f"Medium CVSS ({cvss_score})")
        else:
            reasons.append(f"Low CVSS ({cvss_score})")

        if has_exploit:
            reasons.append(f"{exploit_count} public exploit(s)")
        if len(affected_packages) > 1:
            reasons.append(f"{len(affected_packages)} packages affected")
        if is_fixable:
            reasons.append("Fix available")
        else:
            reasons.append("No fix available")

        return PrioritizedCVE(
            cve_id=cve_id,
            priority_score=round(priority_score, 1),
            priority_tier=priority_tier,
            cvss_score=cvss_score,
            cvss_severity=cvss_severity,
            has_exploit=has_exploit,
            exploit_count=exploit_count,
            affected_packages=affected_packages[:10],  # Limit
            is_fixable=is_fixable,
            fix_version=fix_version,
            reason="; ".join(reasons)
        )

    def prioritize_all(self) -> Dict[str, Any]:
        """Prioritize all CVEs."""
        print("[*] Loading CVE data...")
        self.load_data()

        # Get all unique CVE IDs
        all_cves = set(self.nvd_data.keys())
        all_cves.update([p["cve_id"] for p in self.package_data if p["cve_id"].startswith("CVE-")])

        if not all_cves:
            print("[!] No CVEs found to prioritize")
            return {
                "prioritization_date": datetime.now().isoformat(),
                "total_cves": 0,
                "by_tier": {"CRITICAL": 0, "HIGH": 0, "MEDIUM": 0, "LOW": 0},
                "exploitable_count": 0,
                "fixable_count": 0,
                "prioritized_cves": []
            }

        print(f"[*] Prioritizing {len(all_cves)} CVEs...")

        prioritized = []
        for cve_id in sorted(all_cves):
            priority = self.calculate_priority(cve_id)
            prioritized.append(priority)

        # Sort by priority score descending
        prioritized.sort(key=lambda x: x.priority_score, reverse=True)

        return {
            "prioritization_date": datetime.now().isoformat(),
            "total_cves": len(prioritized),
            "by_tier": {
                "CRITICAL": len([p for p in prioritized if p.priority_tier == "CRITICAL"]),
                "HIGH": len([p for p in prioritized if p.priority_tier == "HIGH"]),
                "MEDIUM": len([p for p in prioritized if p.priority_tier == "MEDIUM"]),
                "LOW": len([p for p in prioritized if p.priority_tier == "LOW"])
            },
            "exploitable_count": len([p for p in prioritized if p.has_exploit]),
            "fixable_count": len([p for p in prioritized if p.is_fixable]),
            "prioritized_cves": [asdict(p) for p in prioritized]
        }

    def generate_remediation_plan(self, results: Dict) -> str:
        """Generate remediation plan based on prioritization."""
        report = f"""# CVE Remediation Prioritization Plan

**Generated:** {results['prioritization_date']}

## Executive Summary

| Metric | Count |
|--------|-------|
| Total CVEs | {results['total_cves']} |
| Critical Priority | {results['by_tier']['CRITICAL']} |
| High Priority | {results['by_tier']['HIGH']} |
| Medium Priority | {results['by_tier']['MEDIUM']} |
| Low Priority | {results['by_tier']['LOW']} |
| Have Known Exploits | {results['exploitable_count']} |
| Have Available Fixes | {results['fixable_count']} |

## Remediation Priority

### Immediate Action Required (Critical Priority)

These vulnerabilities should be addressed within 24-48 hours:

"""
        critical = [c for c in results['prioritized_cves'] if c['priority_tier'] == 'CRITICAL']
        if critical:
            for cve in critical[:10]:
                report += f"""
#### {cve['cve_id']} (Score: {cve['priority_score']})

| Attribute | Value |
|-----------|-------|
| CVSS Score | {cve['cvss_score']} ({cve['cvss_severity']}) |
| Exploit Available | {'Yes' if cve['has_exploit'] else 'No'} |
| Affected Packages | {', '.join(cve['affected_packages'][:5]) or 'Unknown'} |
| Fix Available | {'Yes - ' + cve['fix_version'] if cve['is_fixable'] else 'No'} |

**Reason:** {cve['reason']}

"""
        else:
            report += "\nNo critical priority CVEs identified.\n"

        report += """
### Short-Term Action (High Priority)

Address within the current sprint:

"""
        high = [c for c in results['prioritized_cves'] if c['priority_tier'] == 'HIGH']
        if high:
            for cve in high[:10]:
                report += f"- **{cve['cve_id']}** (Score: {cve['priority_score']}) - "
                report += f"CVSS {cve['cvss_score']}, "
                report += f"{'Exploitable' if cve['has_exploit'] else 'No exploit'}, "
                report += f"{', '.join(cve['affected_packages'][:3]) or 'Unknown'}\n"
        else:
            report += "No high priority CVEs identified.\n"

        report += f"""

### Medium-Term (Medium Priority)

Plan for upcoming releases ({results['by_tier']['MEDIUM']} total):

"""
        medium = [c for c in results['prioritized_cves'] if c['priority_tier'] == 'MEDIUM']
        if medium:
            for cve in medium[:5]:
                report += f"- {cve['cve_id']} - {cve['reason']}\n"
            if len(medium) > 5:
                report += f"- ...and {len(medium) - 5} more\n"
        else:
            report += "No medium priority CVEs identified.\n"

        report += f"""

### Low Priority ({results['by_tier']['LOW']} total)

Address as time permits or during maintenance windows.

## Recommended Actions

### 1. Python Dependencies

```bash
# Check for vulnerable packages
pip-audit

# Automatically fix where possible
pip-audit --fix

# Update specific package
pip install --upgrade <package-name>
```

### 2. Node.js Dependencies

```bash
# Check for vulnerabilities
pnpm audit

# Automatically fix where possible
pnpm audit --fix

# Update specific package
pnpm update <package-name>
```

### 3. Container Images

```bash
# Rebuild with updated base images
docker build --no-cache -t myapp:latest .

# Pull latest base images
docker pull python:3.13-slim
docker pull node:20-alpine
```

### 4. Ongoing Monitoring

1. **Subscribe to security advisories** for key dependencies
2. **Implement CVE scanning in CI/CD** pipeline
3. **Schedule regular dependency updates** (weekly or bi-weekly)
4. **Document risk acceptance** for unfixable CVEs

## Risk Acceptance

For CVEs that cannot be immediately fixed, document:

1. CVE ID and description
2. Reason for delayed remediation
3. Compensating controls in place
4. Target remediation date
5. Responsible owner

---

*This plan was generated automatically by the CVE Prioritization Engine.*
*Review and adjust based on your specific context and risk tolerance.*
"""

        return report


def main():
    print("=" * 50)
    print("CVE Prioritization Engine")
    print("=" * 50)

    prioritizer = CVEPrioritizer()
    results = prioritizer.prioritize_all()

    # Save JSON results
    output_file = Path(SCAN_DIR) / "prioritized_cves.json"
    with open(output_file, "w") as f:
        json.dump(results, f, indent=2)

    # Generate remediation plan
    report = prioritizer.generate_remediation_plan(results)
    report_file = Path(SCAN_DIR) / "REMEDIATION_PLAN.md"
    with open(report_file, "w") as f:
        f.write(report)

    print(f"\n[+] CVE Prioritization complete!")
    print(f"    Total CVEs: {results['total_cves']}")
    print(f"    Critical: {results['by_tier']['CRITICAL']}")
    print(f"    High: {results['by_tier']['HIGH']}")
    print(f"    Medium: {results['by_tier']['MEDIUM']}")
    print(f"    Low: {results['by_tier']['LOW']}")
    print(f"    Exploitable: {results['exploitable_count']}")
    print(f"    Fixable: {results['fixable_count']}")
    print(f"\n    Output: {output_file}")
    print(f"    Plan: {report_file}")


if __name__ == "__main__":
    main()
