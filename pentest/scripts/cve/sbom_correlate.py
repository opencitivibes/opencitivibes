#!/usr/bin/env python3
"""
Correlate SBOM packages with CVE databases for vulnerability assessment.
Uses OSV.dev API for real-time vulnerability lookups.

OpenCitiVibes Penetration Testing - Phase 2
"""

import json
import os
import sys
import time
from datetime import datetime
from pathlib import Path
from typing import Dict, List, Optional

try:
    import requests
    HAS_REQUESTS = True
except ImportError:
    HAS_REQUESTS = False
    print("Warning: requests library not available. Install with: pip install requests", file=sys.stderr)

SCAN_DIR = Path(os.environ.get("SCAN_DIR", "/app/results"))
OSV_API_URL = "https://api.osv.dev/v1/query"


class SBOMCorrelator:
    """Correlate SBOM packages with vulnerability databases."""

    def __init__(self, sbom_dir: Path, cache_dir: Path):
        self.sbom_dir = sbom_dir
        self.cache_dir = cache_dir
        self.cache_dir.mkdir(parents=True, exist_ok=True)
        self.results = []
        self.rate_limit_delay = 0.2  # 200ms between requests

    def load_sbom_packages(self) -> List[Dict]:
        """Load packages from all SBOM files."""
        packages = []

        for sbom_file in self.sbom_dir.glob("sbom-*.json"):
            try:
                with open(sbom_file) as f:
                    sbom = json.load(f)

                component_name = sbom_file.stem.replace("sbom-", "")

                for comp in sbom.get("components", []):
                    packages.append({
                        "name": comp.get("name", ""),
                        "version": comp.get("version", ""),
                        "type": comp.get("type", ""),
                        "purl": comp.get("purl", ""),
                        "source_component": component_name,
                        "sbom_file": str(sbom_file)
                    })

            except Exception as e:
                print(f"Error loading {sbom_file}: {e}", file=sys.stderr)

        return packages

    def query_osv(self, package: Dict) -> List[Dict]:
        """Query OSV.dev for vulnerabilities."""
        if not HAS_REQUESTS:
            return []

        cache_key = f"{package['name']}_{package['version']}".replace("/", "_").replace("@", "_")
        cache_file = self.cache_dir / f"osv_{cache_key}.json"

        # Check cache first
        if cache_file.exists():
            try:
                with open(cache_file) as f:
                    cached = json.load(f)
                # Cache is valid for 24 hours
                cached_time = datetime.fromisoformat(cached.get("cached_at", "2000-01-01"))
                if (datetime.now() - cached_time).total_seconds() < 86400:
                    return cached.get("vulns", [])
            except:
                pass

        # Determine ecosystem from package type or purl
        ecosystem = self._detect_ecosystem(package)

        try:
            response = requests.post(
                OSV_API_URL,
                json={
                    "package": {
                        "name": package["name"],
                        "ecosystem": ecosystem
                    },
                    "version": package["version"]
                },
                timeout=30
            )
            time.sleep(self.rate_limit_delay)

            if response.status_code == 200:
                data = response.json()
                vulns = data.get("vulns", [])

                # Cache the result
                with open(cache_file, "w") as f:
                    json.dump({
                        "cached_at": datetime.now().isoformat(),
                        "vulns": vulns
                    }, f)

                return vulns

        except Exception as e:
            print(f"OSV query failed for {package['name']}: {e}", file=sys.stderr)

        return []

    def _detect_ecosystem(self, package: Dict) -> str:
        """Detect package ecosystem from type or purl."""
        purl = package.get("purl", "")
        pkg_type = package.get("type", "").lower()
        source = package.get("source_component", "").lower()

        if "pypi" in purl or "python" in pkg_type or "backend" in source:
            return "PyPI"
        elif "npm" in purl or "nodejs" in pkg_type or "frontend" in source:
            return "npm"
        elif "golang" in purl or "go" in pkg_type:
            return "Go"
        elif "cargo" in purl or "rust" in pkg_type:
            return "crates.io"
        elif "maven" in purl or "java" in pkg_type:
            return "Maven"

        # Default based on source component
        if "frontend" in source:
            return "npm"
        return "PyPI"

    def extract_severity(self, vuln: Dict) -> Dict:
        """Extract normalized severity information from a vulnerability."""
        severity_info = {"severity": "UNKNOWN", "cvss_score": 0.0, "cvss_vector": ""}

        # Check severity array
        for sev in vuln.get("severity", []):
            if sev.get("type") == "CVSS_V3":
                severity_info["cvss_vector"] = sev.get("score", "")
                # Parse CVSS score from vector if available
                try:
                    vector = sev.get("score", "")
                    if "/" in vector:
                        # Try to extract numeric score
                        pass
                except:
                    pass

        # Check database_specific for CVSS
        db_specific = vuln.get("database_specific", {})
        if "cvss_v3" in db_specific:
            cvss = db_specific["cvss_v3"]
            if isinstance(cvss, dict):
                severity_info["cvss_score"] = cvss.get("score", 0.0)
            elif isinstance(cvss, (int, float)):
                severity_info["cvss_score"] = cvss

        # Check for severity in database_specific
        if "severity" in db_specific:
            sev = db_specific["severity"]
            if isinstance(sev, str):
                severity_info["severity"] = sev.upper()

        # Calculate severity from CVSS score
        score = severity_info["cvss_score"]
        if score >= 9.0:
            severity_info["severity"] = "CRITICAL"
        elif score >= 7.0:
            severity_info["severity"] = "HIGH"
        elif score >= 4.0:
            severity_info["severity"] = "MEDIUM"
        elif score > 0:
            severity_info["severity"] = "LOW"

        return severity_info

    def correlate_all(self) -> Dict:
        """Correlate all SBOM packages with CVE databases."""
        packages = self.load_sbom_packages()
        print(f"Loaded {len(packages)} packages from SBOMs")

        vulnerable_packages = []
        total_vulns = 0
        checked = 0

        for i, pkg in enumerate(packages):
            if not pkg["name"] or not pkg["version"]:
                continue

            checked += 1
            print(f"[{i+1}/{len(packages)}] Checking {pkg['name']}@{pkg['version']}...", end=" ")

            vulns = self.query_osv(pkg)

            if vulns:
                total_vulns += len(vulns)
                print(f"VULNERABLE ({len(vulns)} CVE(s))")

                # Extract CVE IDs and severity
                vuln_details = []
                for v in vulns:
                    sev = self.extract_severity(v)
                    vuln_details.append({
                        "id": v.get("id", ""),
                        "summary": v.get("summary", "")[:100],
                        "severity": sev["severity"],
                        "cvss_score": sev["cvss_score"],
                        "aliases": v.get("aliases", [])
                    })

                vulnerable_packages.append({
                    **pkg,
                    "vulnerabilities": vuln_details,
                    "vuln_count": len(vulns)
                })
            else:
                print("OK")

        # Sort by vulnerability count
        vulnerable_packages.sort(key=lambda x: x["vuln_count"], reverse=True)

        return {
            "correlation_date": datetime.now().isoformat(),
            "total_packages": len(packages),
            "packages_checked": checked,
            "vulnerable_packages": len(vulnerable_packages),
            "total_vulnerabilities": total_vulns,
            "by_component": self._group_by_component(vulnerable_packages),
            "by_severity": self._group_by_severity(vulnerable_packages),
            "packages": vulnerable_packages
        }

    def _group_by_component(self, packages: List[Dict]) -> Dict:
        """Group vulnerabilities by source component."""
        by_component = {}
        for pkg in packages:
            comp = pkg["source_component"]
            if comp not in by_component:
                by_component[comp] = {"packages": 0, "vulns": 0}
            by_component[comp]["packages"] += 1
            by_component[comp]["vulns"] += pkg["vuln_count"]
        return by_component

    def _group_by_severity(self, packages: List[Dict]) -> Dict:
        """Group vulnerabilities by severity."""
        by_severity = {"CRITICAL": 0, "HIGH": 0, "MEDIUM": 0, "LOW": 0, "UNKNOWN": 0}
        for pkg in packages:
            for vuln in pkg.get("vulnerabilities", []):
                sev = vuln.get("severity", "UNKNOWN")
                if sev in by_severity:
                    by_severity[sev] += 1
        return by_severity


def main():
    sbom_dir = SCAN_DIR / "sbom"
    cache_dir = SCAN_DIR / "cve_cache"

    if not sbom_dir.exists():
        print(f"SBOM directory not found: {sbom_dir}")
        print("Run generate-sbom.sh first")
        sys.exit(1)

    correlator = SBOMCorrelator(sbom_dir, cache_dir)
    results = correlator.correlate_all()

    # Write results
    output_file = SCAN_DIR / "sbom_cve_correlation.json"
    with open(output_file, "w") as f:
        json.dump(results, f, indent=2)

    # Generate summary
    print(f"\n{'='*60}")
    print("SBOM-CVE Correlation Complete!")
    print(f"{'='*60}")
    print(f"Total packages: {results['total_packages']}")
    print(f"Packages checked: {results['packages_checked']}")
    print(f"Vulnerable packages: {results['vulnerable_packages']}")
    print(f"Total vulnerabilities: {results['total_vulnerabilities']}")
    print()
    print("By Severity:")
    for sev, count in results['by_severity'].items():
        if count > 0:
            print(f"  {sev}: {count}")
    print()
    print("By Component:")
    for comp, data in results['by_component'].items():
        print(f"  {comp}: {data['packages']} pkg(s), {data['vulns']} vuln(s)")
    print()
    print(f"Results saved to: {output_file}")

    # Generate markdown summary
    summary_file = SCAN_DIR / "sbom_cve_summary.md"
    with open(summary_file, "w") as f:
        f.write("# SBOM-CVE Correlation Summary\n\n")
        f.write(f"**Date:** {results['correlation_date']}\n\n")
        f.write("## Overview\n\n")
        f.write(f"- Total packages: {results['total_packages']}\n")
        f.write(f"- Vulnerable packages: {results['vulnerable_packages']}\n")
        f.write(f"- Total vulnerabilities: {results['total_vulnerabilities']}\n\n")
        f.write("## Severity Distribution\n\n")
        f.write("| Severity | Count |\n|----------|-------|\n")
        for sev, count in results['by_severity'].items():
            f.write(f"| {sev} | {count} |\n")
        f.write("\n## Top Vulnerable Packages\n\n")
        for pkg in results['packages'][:10]:
            f.write(f"### {pkg['name']}@{pkg['version']}\n\n")
            f.write(f"- Component: {pkg['source_component']}\n")
            f.write(f"- Vulnerabilities: {pkg['vuln_count']}\n\n")
            for vuln in pkg['vulnerabilities'][:5]:
                f.write(f"  - **{vuln['id']}** ({vuln['severity']}): {vuln['summary']}\n")
            f.write("\n")


if __name__ == "__main__":
    main()
