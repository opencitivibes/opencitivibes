#!/usr/bin/env python3
"""
OSV.dev API Client for vulnerability lookups.
https://osv.dev/docs/

This module provides a client for querying the OSV (Open Source Vulnerabilities)
database, which aggregates vulnerability data from multiple sources including
GitHub Security Advisories, PyPI, npm, and more.
"""

import json
import os
import time
import hashlib
from datetime import datetime, timedelta
from pathlib import Path
from typing import Dict, List, Optional, Any

try:
    import requests
    HAS_REQUESTS = True
except ImportError:
    HAS_REQUESTS = False
    print("[!] requests library not available - OSV queries will be disabled")


OSV_API_URL = "https://api.osv.dev/v1"


class OSVClient:
    """Client for querying OSV.dev vulnerability database."""

    def __init__(
        self,
        cache_dir: Optional[Path] = None,
        cache_ttl_hours: int = 24,
        rate_limit_delay: float = 0.1
    ):
        """
        Initialize OSV client.

        Args:
            cache_dir: Directory for caching results (default: /tmp/osv_cache)
            cache_ttl_hours: Cache time-to-live in hours (default: 24)
            rate_limit_delay: Delay between requests in seconds (default: 0.1)
        """
        self.cache_dir = cache_dir or Path("/tmp/osv_cache")
        self.cache_dir.mkdir(parents=True, exist_ok=True)
        self.cache_ttl = timedelta(hours=cache_ttl_hours)
        self.rate_limit_delay = rate_limit_delay
        self.request_count = 0

    def _cache_key(self, package: str, version: str, ecosystem: str) -> str:
        """Generate cache key for a package query."""
        key = f"{ecosystem}:{package}:{version}"
        return hashlib.md5(key.encode()).hexdigest()

    def _get_cached(self, cache_key: str) -> Optional[List[Dict]]:
        """Get cached vulnerability data if valid."""
        cache_file = self.cache_dir / f"{cache_key}.json"
        if cache_file.exists():
            try:
                with open(cache_file) as f:
                    cached = json.load(f)
                cached_time = datetime.fromisoformat(cached.get("cached_at", ""))
                if datetime.now() - cached_time < self.cache_ttl:
                    return cached.get("vulns", [])
            except (json.JSONDecodeError, ValueError, KeyError):
                # Invalid cache, will refresh
                pass
        return None

    def _set_cached(self, cache_key: str, vulns: List[Dict]):
        """Cache vulnerability data."""
        cache_file = self.cache_dir / f"{cache_key}.json"
        with open(cache_file, "w") as f:
            json.dump({
                "cached_at": datetime.now().isoformat(),
                "vulns": vulns
            }, f)

    def query_package(
        self,
        package: str,
        version: str,
        ecosystem: str = "PyPI"
    ) -> List[Dict]:
        """
        Query OSV for vulnerabilities affecting a specific package version.

        Args:
            package: Package name (e.g., "requests")
            version: Package version (e.g., "2.28.0")
            ecosystem: Package ecosystem (PyPI, npm, Go, etc.)

        Returns:
            List of vulnerability dictionaries
        """
        if not HAS_REQUESTS:
            return []

        cache_key = self._cache_key(package, version, ecosystem)
        cached = self._get_cached(cache_key)
        if cached is not None:
            return cached

        try:
            response = requests.post(
                f"{OSV_API_URL}/query",
                json={
                    "package": {"name": package, "ecosystem": ecosystem},
                    "version": version
                },
                timeout=30
            )
            self.request_count += 1
            time.sleep(self.rate_limit_delay)

            if response.status_code == 200:
                data = response.json()
                vulns = data.get("vulns", [])
                self._set_cached(cache_key, vulns)
                return vulns
            elif response.status_code == 404:
                # Package not found, cache empty result
                self._set_cached(cache_key, [])
                return []
            else:
                print(f"[!] OSV API error for {package}@{version}: HTTP {response.status_code}")
        except requests.RequestException as e:
            print(f"[!] OSV query failed for {package}@{version}: {e}")

        return []

    def query_batch(
        self,
        packages: List[Dict[str, str]],
        ecosystem: str = "PyPI"
    ) -> Dict[str, List[Dict]]:
        """
        Query OSV for multiple packages.

        Args:
            packages: List of {"name": "pkg", "version": "1.0"} dicts
            ecosystem: Package ecosystem

        Returns:
            Dict mapping "pkg@version" to vulnerability list
        """
        if not HAS_REQUESTS:
            return {}

        results = {}

        # OSV batch endpoint
        queries = []
        for pkg in packages:
            name = pkg.get("name")
            version = pkg.get("version")
            if name and version:
                cache_key = self._cache_key(name, version, ecosystem)
                cached = self._get_cached(cache_key)
                if cached is not None:
                    results[f"{name}@{version}"] = cached
                else:
                    queries.append({
                        "package": {"name": name, "ecosystem": ecosystem},
                        "version": version
                    })

        if not queries:
            return results

        # Batch query (max 1000 per request)
        for i in range(0, len(queries), 1000):
            batch = queries[i:i+1000]
            try:
                response = requests.post(
                    f"{OSV_API_URL}/querybatch",
                    json={"queries": batch},
                    timeout=60
                )
                self.request_count += 1
                time.sleep(self.rate_limit_delay)

                if response.status_code == 200:
                    data = response.json()
                    for j, result in enumerate(data.get("results", [])):
                        query = batch[j]
                        name = query["package"]["name"]
                        version = query["version"]
                        vulns = result.get("vulns", [])

                        key = f"{name}@{version}"
                        results[key] = vulns

                        # Cache individual results
                        cache_key = self._cache_key(name, version, ecosystem)
                        self._set_cached(cache_key, vulns)

            except requests.RequestException as e:
                print(f"[!] OSV batch query failed: {e}")

        return results

    def get_vulnerability_details(self, vuln_id: str) -> Optional[Dict]:
        """
        Get detailed information about a specific vulnerability.

        Args:
            vuln_id: Vulnerability ID (e.g., "GHSA-xxx-xxx-xxx", "CVE-2024-1234")

        Returns:
            Vulnerability details dict or None
        """
        if not HAS_REQUESTS:
            return None

        try:
            response = requests.get(
                f"{OSV_API_URL}/vulns/{vuln_id}",
                timeout=30
            )
            self.request_count += 1
            time.sleep(self.rate_limit_delay)

            if response.status_code == 200:
                return response.json()
        except requests.RequestException as e:
            print(f"[!] OSV detail query failed for {vuln_id}: {e}")

        return None

    def extract_severity(self, vuln: Dict) -> Dict[str, Any]:
        """
        Extract normalized severity information from a vulnerability.

        Args:
            vuln: OSV vulnerability dictionary

        Returns:
            Dict with severity, cvss_score, cvss_vector
        """
        severity_info = {
            "severity": "UNKNOWN",
            "cvss_score": 0.0,
            "cvss_vector": ""
        }

        # Try to get CVSS from severity array
        for sev in vuln.get("severity", []):
            if sev.get("type") == "CVSS_V3":
                severity_info["cvss_vector"] = sev.get("score", "")

        # Try to get from database_specific
        db_specific = vuln.get("database_specific", {})
        if "cvss_v3" in db_specific:
            cvss = db_specific["cvss_v3"]
            if isinstance(cvss, dict):
                severity_info["cvss_score"] = cvss.get("score", 0.0)
            elif isinstance(cvss, (int, float)):
                severity_info["cvss_score"] = cvss

        # Calculate severity from score
        score = severity_info["cvss_score"]
        if score >= 9.0:
            severity_info["severity"] = "CRITICAL"
        elif score >= 7.0:
            severity_info["severity"] = "HIGH"
        elif score >= 4.0:
            severity_info["severity"] = "MEDIUM"
        elif score > 0:
            severity_info["severity"] = "LOW"

        # Fallback to ecosystem-specific severity
        if severity_info["severity"] == "UNKNOWN":
            ecosystem_sev = db_specific.get("severity")
            if ecosystem_sev:
                severity_info["severity"] = ecosystem_sev.upper()

        return severity_info

    def format_finding(self, pkg_name: str, pkg_version: str, vuln: Dict) -> Dict:
        """
        Format OSV vulnerability as a standardized finding.

        Args:
            pkg_name: Package name
            pkg_version: Package version
            vuln: OSV vulnerability dictionary

        Returns:
            Standardized finding dict
        """
        severity_info = self.extract_severity(vuln)

        # Extract CVE aliases
        aliases = vuln.get("aliases", [])
        cve_ids = [a for a in aliases if a.startswith("CVE-")]

        # Get references
        references = [ref.get("url") for ref in vuln.get("references", []) if ref.get("url")]

        return {
            "id": vuln.get("id", "UNKNOWN"),
            "title": vuln.get("summary", "Unknown Vulnerability"),
            "description": vuln.get("details", ""),
            "package": pkg_name,
            "version": pkg_version,
            "severity": severity_info["severity"],
            "cvss_score": severity_info["cvss_score"],
            "cvss_vector": severity_info["cvss_vector"],
            "cve_ids": cve_ids,
            "references": references[:5],  # Limit references
            "fixed_versions": self._extract_fixed_versions(vuln, pkg_name),
            "source": "OSV",
            "published": vuln.get("published", ""),
            "modified": vuln.get("modified", "")
        }

    def _extract_fixed_versions(self, vuln: Dict, pkg_name: str) -> List[str]:
        """Extract fixed versions from OSV affected data."""
        fixed = []
        for affected in vuln.get("affected", []):
            if affected.get("package", {}).get("name") == pkg_name:
                for range_data in affected.get("ranges", []):
                    for event in range_data.get("events", []):
                        if "fixed" in event:
                            fixed.append(event["fixed"])
        return fixed


def main():
    """CLI interface for OSV client."""
    import argparse

    parser = argparse.ArgumentParser(description="OSV.dev vulnerability lookup")
    parser.add_argument("--package", "-p", required=True, help="Package name")
    parser.add_argument("--version", "-v", required=True, help="Package version")
    parser.add_argument(
        "--ecosystem", "-e",
        default="PyPI",
        choices=["PyPI", "npm", "Go", "Maven", "Packagist", "RubyGems", "crates.io"],
        help="Package ecosystem"
    )
    parser.add_argument("--json", action="store_true", help="Output as JSON")

    args = parser.parse_args()

    client = OSVClient()
    vulns = client.query_package(args.package, args.version, args.ecosystem)

    if args.json:
        findings = [
            client.format_finding(args.package, args.version, v)
            for v in vulns
        ]
        print(json.dumps(findings, indent=2))
    else:
        if vulns:
            print(f"\n[*] Found {len(vulns)} vulnerabilities for {args.package}@{args.version}")
            for v in vulns:
                severity = client.extract_severity(v)
                print(f"\n  - {v.get('id')}: {v.get('summary', 'N/A')}")
                print(f"    Severity: {severity['severity']} (CVSS: {severity['cvss_score']})")
        else:
            print(f"\n[+] No known vulnerabilities for {args.package}@{args.version}")


if __name__ == "__main__":
    main()
