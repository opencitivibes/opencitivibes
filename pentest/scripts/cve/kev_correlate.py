#!/usr/bin/env python3
"""
CISA KEV (Known Exploited Vulnerabilities) Correlation.
https://www.cisa.gov/known-exploited-vulnerabilities-catalog

This module downloads and parses the CISA KEV catalog, which contains
vulnerabilities that are known to be actively exploited in the wild.
Findings matching KEV entries should be treated as highest priority.
"""

import json
import os
import argparse
from datetime import datetime
from pathlib import Path
from typing import Dict, List, Set, Optional

try:
    import requests
    HAS_REQUESTS = True
except ImportError:
    HAS_REQUESTS = False
    print("[!] requests library not available - KEV downloads will be disabled")


KEV_CATALOG_URL = "https://www.cisa.gov/sites/default/files/feeds/known_exploited_vulnerabilities.json"


class KEVCorrelator:
    """Correlate findings with CISA KEV catalog."""

    def __init__(self, cache_dir: Optional[Path] = None, cache_ttl_hours: int = 24):
        """
        Initialize KEV correlator.

        Args:
            cache_dir: Directory for caching the KEV catalog
            cache_ttl_hours: How long to cache the catalog (default: 24 hours)
        """
        self.cache_dir = cache_dir or Path("/tmp/kev_cache")
        self.cache_dir.mkdir(parents=True, exist_ok=True)
        self.cache_file = self.cache_dir / "kev_catalog.json"
        self.cache_ttl_hours = cache_ttl_hours
        self.kev_cves: Set[str] = set()
        self.kev_data: Dict[str, Dict] = {}  # CVE -> full KEV entry
        self._load_catalog()

    def _is_cache_valid(self) -> bool:
        """Check if cached catalog is still valid."""
        if not self.cache_file.exists():
            return False
        mtime = datetime.fromtimestamp(self.cache_file.stat().st_mtime)
        age_hours = (datetime.now() - mtime).total_seconds() / 3600
        return age_hours < self.cache_ttl_hours

    def _load_catalog(self):
        """Load KEV catalog, downloading if necessary."""
        if self._is_cache_valid():
            self._parse_catalog()
        else:
            self._download_catalog()
            self._parse_catalog()

    def _download_catalog(self):
        """Download the KEV catalog from CISA."""
        if not HAS_REQUESTS:
            print("[!] Cannot download KEV catalog - requests library not available")
            return

        try:
            print("[*] Downloading KEV catalog from CISA...")
            response = requests.get(KEV_CATALOG_URL, timeout=60)
            if response.status_code == 200:
                with open(self.cache_file, "w") as f:
                    f.write(response.text)
                print(f"[+] KEV catalog saved to {self.cache_file}")
            else:
                print(f"[!] Failed to download KEV catalog: HTTP {response.status_code}")
        except requests.RequestException as e:
            print(f"[!] Failed to download KEV catalog: {e}")

    def _parse_catalog(self):
        """Parse the KEV catalog and extract CVE IDs."""
        if not self.cache_file.exists():
            print("[!] KEV catalog not found")
            return

        try:
            with open(self.cache_file) as f:
                catalog = json.load(f)

            for vuln in catalog.get("vulnerabilities", []):
                cve_id = vuln.get("cveID", "")
                if cve_id.startswith("CVE-"):
                    self.kev_cves.add(cve_id)
                    self.kev_data[cve_id] = {
                        "vendor": vuln.get("vendorProject", ""),
                        "product": vuln.get("product", ""),
                        "name": vuln.get("vulnerabilityName", ""),
                        "description": vuln.get("shortDescription", ""),
                        "date_added": vuln.get("dateAdded", ""),
                        "due_date": vuln.get("dueDate", ""),
                        "notes": vuln.get("notes", ""),
                        "known_ransomware": vuln.get("knownRansomwareCampaignUse", "Unknown") == "Known"
                    }

            print(f"[+] Loaded {len(self.kev_cves)} CVEs from KEV catalog")

        except (json.JSONDecodeError, IOError) as e:
            print(f"[!] Failed to parse KEV catalog: {e}")

    def is_kev(self, cve_id: str) -> bool:
        """
        Check if a CVE is in the KEV catalog.

        Args:
            cve_id: CVE identifier (e.g., "CVE-2021-44228")

        Returns:
            True if CVE is in KEV catalog
        """
        return cve_id.upper() in self.kev_cves

    def get_kev_info(self, cve_id: str) -> Optional[Dict]:
        """
        Get KEV information for a specific CVE.

        Args:
            cve_id: CVE identifier

        Returns:
            KEV entry dict or None
        """
        return self.kev_data.get(cve_id.upper())

    def correlate_findings(self, findings: List[Dict]) -> List[Dict]:
        """
        Correlate findings with KEV catalog and upgrade severity.

        Findings matching KEV entries are:
        1. Marked with is_kev = True
        2. Upgraded to CRITICAL severity
        3. Annotated with KEV warning

        Args:
            findings: List of finding dicts with cve/cve_id fields

        Returns:
            List of findings with KEV annotations
        """
        kev_findings = []

        for finding in findings:
            cve_ids = self._extract_cve_ids(finding)
            kev_cves = [cve for cve in cve_ids if self.is_kev(cve)]
            is_kev = len(kev_cves) > 0

            annotated = finding.copy()
            annotated["is_kev"] = is_kev
            annotated["kev_cves"] = kev_cves

            if is_kev:
                # Get KEV details for first matching CVE
                kev_info = self.get_kev_info(kev_cves[0])
                annotated["kev_warning"] = "ACTIVELY EXPLOITED IN THE WILD!"
                annotated["kev_info"] = kev_info

                # Upgrade severity to CRITICAL
                if annotated.get("severity", "").upper() != "CRITICAL":
                    annotated["original_severity"] = annotated.get("severity")
                    annotated["severity"] = "CRITICAL"

                # Mark if known ransomware use
                if kev_info and kev_info.get("known_ransomware"):
                    annotated["kev_ransomware"] = True
                    annotated["kev_warning"] += " Known ransomware campaign use!"

            kev_findings.append(annotated)

        return kev_findings

    def _extract_cve_ids(self, finding: Dict) -> List[str]:
        """Extract CVE IDs from a finding dictionary."""
        cves = []

        # Check common field names
        for field in ["cve", "cve_id", "cve_ids", "id", "aliases", "references"]:
            value = finding.get(field)

            if isinstance(value, str) and value.upper().startswith("CVE-"):
                cves.append(value.upper())
            elif isinstance(value, list):
                for item in value:
                    if isinstance(item, str) and item.upper().startswith("CVE-"):
                        cves.append(item.upper())

        return list(set(cves))

    def generate_summary(self) -> Dict:
        """Generate summary of KEV catalog."""
        ransomware_cves = [
            cve for cve, info in self.kev_data.items()
            if info.get("known_ransomware")
        ]

        return {
            "total_kevs": len(self.kev_cves),
            "ransomware_kevs": len(ransomware_cves),
            "catalog_date": self.cache_file.stat().st_mtime if self.cache_file.exists() else None,
            "sample_cves": list(self.kev_cves)[:10]
        }


def correlate_scan_results(scan_dir: Path, correlator: KEVCorrelator) -> Dict:
    """
    Correlate all scan results in a directory with KEV catalog.

    Args:
        scan_dir: Directory containing scan result JSON files
        correlator: KEVCorrelator instance

    Returns:
        Summary of KEV matches
    """
    kev_matches = []
    files_processed = 0

    for json_file in scan_dir.rglob("*.json"):
        try:
            with open(json_file) as f:
                data = json.load(f)

            findings = []

            # Handle different JSON formats
            if isinstance(data, list):
                findings = data
            elif isinstance(data, dict):
                findings = data.get("findings", data.get("results", data.get("vulnerabilities", [])))

            if findings:
                correlated = correlator.correlate_findings(findings)
                kev_matches.extend([f for f in correlated if f.get("is_kev")])
                files_processed += 1

        except (json.JSONDecodeError, IOError):
            continue

    return {
        "files_processed": files_processed,
        "kev_matches": len(kev_matches),
        "findings": kev_matches
    }


def main():
    """CLI interface for KEV correlation."""
    parser = argparse.ArgumentParser(
        description="CISA KEV (Known Exploited Vulnerabilities) Correlation"
    )
    parser.add_argument(
        "--cve",
        help="Check if a specific CVE is in KEV catalog"
    )
    parser.add_argument(
        "--scan-dir",
        type=Path,
        help="Directory with scan results to correlate"
    )
    parser.add_argument(
        "--update",
        action="store_true",
        help="Force update of KEV catalog"
    )
    parser.add_argument(
        "--summary",
        action="store_true",
        help="Print KEV catalog summary"
    )
    parser.add_argument(
        "--json",
        action="store_true",
        help="Output as JSON"
    )

    args = parser.parse_args()

    # Force update if requested
    if args.update:
        correlator = KEVCorrelator(cache_ttl_hours=0)
    else:
        correlator = KEVCorrelator()

    if args.cve:
        # Check specific CVE
        is_kev = correlator.is_kev(args.cve)
        info = correlator.get_kev_info(args.cve)

        if args.json:
            print(json.dumps({
                "cve": args.cve,
                "is_kev": is_kev,
                "info": info
            }, indent=2))
        else:
            if is_kev:
                print(f"\n[!] {args.cve} IS IN KEV CATALOG - ACTIVELY EXPLOITED!")
                if info:
                    print(f"    Vendor: {info.get('vendor')}")
                    print(f"    Product: {info.get('product')}")
                    print(f"    Name: {info.get('name')}")
                    print(f"    Added: {info.get('date_added')}")
                    if info.get('known_ransomware'):
                        print(f"    [!] Known ransomware campaign use!")
            else:
                print(f"\n[+] {args.cve} is not in KEV catalog")

    elif args.scan_dir:
        # Correlate scan results
        results = correlate_scan_results(args.scan_dir, correlator)

        if args.json:
            print(json.dumps(results, indent=2))
        else:
            print(f"\n[*] Processed {results['files_processed']} files")
            print(f"[*] Found {results['kev_matches']} KEV matches\n")
            for finding in results['findings'][:10]:
                print(f"  - {finding.get('kev_cves', ['Unknown'])[0]}: {finding.get('title', 'N/A')}")
                print(f"    Severity: {finding.get('severity')}")
                if finding.get('kev_ransomware'):
                    print(f"    [!] Known ransomware use!")

    elif args.summary:
        # Print summary
        summary = correlator.generate_summary()

        if args.json:
            print(json.dumps(summary, indent=2))
        else:
            print(f"\n[*] KEV Catalog Summary")
            print(f"    Total CVEs: {summary['total_kevs']}")
            print(f"    Ransomware CVEs: {summary['ransomware_kevs']}")
            print(f"    Sample CVEs: {', '.join(summary['sample_cves'][:5])}")

    else:
        parser.print_help()


if __name__ == "__main__":
    main()
