#!/usr/bin/env python3
"""
Exploit-DB and SearchSploit Cross-Reference.

Checks discovered CVEs against Exploit-DB for known exploits,
providing exploitability assessment for prioritization.

Usage:
    SCAN_DIR=/app/results/cve python exploitdb_check.py
"""

import json
import os
import subprocess
import re
from pathlib import Path
from typing import Dict, List, Optional, Any
from datetime import datetime

SCAN_DIR = os.environ.get("SCAN_DIR", "/app/results/cve")


class ExploitDBChecker:
    def __init__(self):
        self.scan_dir = Path(SCAN_DIR)
        self.exploits_found = []
        self.searchsploit_available = self._check_searchsploit()

    def _check_searchsploit(self) -> bool:
        """Check if searchsploit is available."""
        try:
            result = subprocess.run(
                ["which", "searchsploit"],
                capture_output=True,
                timeout=5
            )
            return result.returncode == 0
        except Exception:
            return False

    def check_searchsploit(self, cve_id: str) -> List[Dict]:
        """Use searchsploit to find exploits for a CVE."""
        if not self.searchsploit_available:
            return []

        exploits = []

        try:
            result = subprocess.run(
                ["searchsploit", "--cve", cve_id, "--json"],
                capture_output=True,
                text=True,
                timeout=30
            )

            if result.returncode == 0 and result.stdout.strip():
                try:
                    data = json.loads(result.stdout)
                    for exploit in data.get("RESULTS_EXPLOIT", []):
                        exploits.append({
                            "cve_id": cve_id,
                            "title": exploit.get("Title", ""),
                            "path": exploit.get("Path", ""),
                            "type": exploit.get("Type", ""),
                            "platform": exploit.get("Platform", ""),
                            "date": exploit.get("Date", ""),
                            "author": exploit.get("Author", "")
                        })
                except json.JSONDecodeError:
                    # Try parsing plain text output
                    if "Exploit Title" in result.stdout:
                        exploits.append({
                            "cve_id": cve_id,
                            "title": "Exploit found (see searchsploit)",
                            "path": "",
                            "type": "unknown",
                            "platform": "unknown"
                        })

        except subprocess.TimeoutExpired:
            print(f"    [!] Timeout searching for {cve_id}")
        except FileNotFoundError:
            print("    [!] searchsploit not found")
            self.searchsploit_available = False
        except Exception as e:
            print(f"    [!] Error checking {cve_id}: {e}")

        return exploits

    def check_keyword_search(self, package_name: str, version: str = "") -> List[Dict]:
        """Search for exploits by package name and version."""
        if not self.searchsploit_available:
            return []

        exploits = []
        search_term = f"{package_name} {version}".strip()

        try:
            result = subprocess.run(
                ["searchsploit", search_term, "--json"],
                capture_output=True,
                text=True,
                timeout=30
            )

            if result.returncode == 0 and result.stdout.strip():
                try:
                    data = json.loads(result.stdout)
                    for exploit in data.get("RESULTS_EXPLOIT", []):
                        exploits.append({
                            "search_term": search_term,
                            "title": exploit.get("Title", ""),
                            "path": exploit.get("Path", ""),
                            "type": exploit.get("Type", ""),
                            "platform": exploit.get("Platform", "")
                        })
                except json.JSONDecodeError:
                    pass

        except Exception:
            pass

        return exploits

    def load_nvd_correlation(self) -> List[Dict]:
        """Load CVE data from NVD correlation results."""
        nvd_file = self.scan_dir / "nvd_correlation.json"
        if not nvd_file.exists():
            print("[!] No NVD correlation found - run nvd_correlate.py first")
            return []

        try:
            with open(nvd_file, "r") as f:
                data = json.load(f)
            return data.get("cves", [])
        except Exception as e:
            print(f"[!] Error loading NVD data: {e}")
            return []

    def extract_packages_from_scans(self) -> List[Dict]:
        """Extract vulnerable packages from scan results."""
        packages = []

        # Parse Trivy results
        for trivy_file in self.scan_dir.glob("**/trivy-*.json"):
            try:
                with open(trivy_file, "r") as f:
                    data = json.load(f)

                for result in data.get("Results", []):
                    for vuln in result.get("Vulnerabilities", []):
                        packages.append({
                            "name": vuln.get("PkgName", ""),
                            "version": vuln.get("InstalledVersion", ""),
                            "cve_id": vuln.get("VulnerabilityID", "")
                        })
            except Exception:
                pass

        # Parse Grype results
        for grype_file in self.scan_dir.glob("**/grype-*.json"):
            try:
                with open(grype_file, "r") as f:
                    data = json.load(f)

                for match in data.get("matches", []):
                    artifact = match.get("artifact", {})
                    packages.append({
                        "name": artifact.get("name", ""),
                        "version": artifact.get("version", ""),
                        "cve_id": match.get("vulnerability", {}).get("id", "")
                    })
            except Exception:
                pass

        return packages

    def check_all_cves(self) -> Dict[str, Any]:
        """Check all CVEs from correlation against Exploit-DB."""
        print("[*] Loading CVE data...")

        # Get CVEs from NVD correlation or scan results
        cves = self.load_nvd_correlation()
        cve_ids = [c["id"] for c in cves] if cves else []

        if not cve_ids:
            # Try to extract CVEs directly from scan files
            print("[*] Extracting CVEs from scan results...")
            packages = self.extract_packages_from_scans()
            cve_ids = list(set([p["cve_id"] for p in packages if p["cve_id"].startswith("CVE-")]))

        if not cve_ids:
            print("[!] No CVEs found to check")
            return {
                "check_date": datetime.now().isoformat(),
                "total_cves_checked": 0,
                "exploitable_cves": 0,
                "exploitable_cve_list": [],
                "exploits_by_cve": [],
                "exploits_by_package": [],
                "summary": {"high_priority": []}
            }

        if not self.searchsploit_available:
            print("[!] searchsploit not available - install exploitdb package")
            return {
                "check_date": datetime.now().isoformat(),
                "total_cves_checked": len(cve_ids),
                "exploitable_cves": 0,
                "exploitable_cve_list": [],
                "exploits_by_cve": [],
                "exploits_by_package": [],
                "summary": {"high_priority": []},
                "note": "searchsploit not available"
            }

        print(f"[*] Checking {len(cve_ids)} CVEs against Exploit-DB...")

        all_exploits = []
        exploitable_cves = set()

        for i, cve_id in enumerate(cve_ids):
            print(f"    [{i+1}/{len(cve_ids)}] {cve_id}", end="")
            exploits = self.check_searchsploit(cve_id)
            if exploits:
                all_exploits.extend(exploits)
                exploitable_cves.add(cve_id)
                print(f" - Found {len(exploits)} exploit(s)!")
            else:
                print("")

        # Also check common vulnerable packages
        print("\n[*] Checking vulnerable packages by name...")
        packages = self.extract_packages_from_scans()
        unique_packages = list({(p["name"], p["version"]) for p in packages if p["name"]})

        package_exploits = []
        checked = 0
        for name, version in unique_packages[:50]:  # Limit to prevent too many queries
            if name and len(name) > 2:  # Skip very short names
                exploits = self.check_keyword_search(name, version)
                if exploits:
                    package_exploits.extend(exploits)
                    print(f"    [!] {name} {version}: {len(exploits)} potential exploit(s)")
                checked += 1

        # Identify high priority (high CVSS + exploit available)
        high_priority = []
        for cve_id in exploitable_cves:
            cve_data = next((c for c in cves if c.get("id") == cve_id), None)
            if cve_data and cve_data.get("cvss", {}).get("score", 0) >= 7.0:
                high_priority.append(cve_id)

        return {
            "check_date": datetime.now().isoformat(),
            "total_cves_checked": len(cve_ids),
            "exploitable_cves": len(exploitable_cves),
            "exploitable_cve_list": list(exploitable_cves),
            "exploits_by_cve": all_exploits,
            "exploits_by_package": package_exploits,
            "summary": {
                "high_priority": high_priority
            }
        }

    def generate_exploitability_report(self, results: Dict) -> str:
        """Generate human-readable exploitability report."""
        report = f"""# Exploit-DB Cross-Reference Report

**Date:** {results['check_date']}

## Summary

- **CVEs Checked:** {results['total_cves_checked']}
- **Exploitable CVEs:** {results['exploitable_cves']}
- **High Priority (CVSS >= 7.0 + Exploit):** {len(results['summary']['high_priority'])}

"""

        if results.get("note"):
            report += f"**Note:** {results['note']}\n\n"

        if results['summary']['high_priority']:
            report += """## High Priority Exploitable CVEs

These CVEs have known public exploits AND high CVSS scores:

"""
            for cve_id in results['summary']['high_priority']:
                report += f"### {cve_id}\n\n"
                for exploit in results['exploits_by_cve']:
                    if exploit['cve_id'] == cve_id:
                        report += f"- **{exploit['title']}**\n"
                        report += f"  - Type: {exploit['type']}\n"
                        report += f"  - Platform: {exploit['platform']}\n"
                        if exploit.get('path'):
                            report += f"  - Path: `{exploit['path']}`\n"
                report += "\n"
        else:
            report += "## High Priority Exploitable CVEs\n\nNo high priority exploitable CVEs found.\n\n"

        if results['exploits_by_cve']:
            report += "## All Exploits Found by CVE\n\n"

            by_cve = {}
            for exploit in results['exploits_by_cve']:
                cve_id = exploit['cve_id']
                if cve_id not in by_cve:
                    by_cve[cve_id] = []
                by_cve[cve_id].append(exploit)

            for cve_id, exploits in sorted(by_cve.items()):
                if cve_id not in results['summary']['high_priority']:
                    report += f"### {cve_id}\n\n"
                    for exploit in exploits:
                        report += f"- {exploit['title']} ({exploit['type']})\n"
                    report += "\n"

        if results['exploits_by_package']:
            report += "## Package-Based Exploits\n\n"
            report += "These may be false positives - verify manually:\n\n"

            for exploit in results['exploits_by_package'][:20]:
                report += f"- **{exploit['search_term']}**: {exploit['title']}\n"

        report += """

## Recommendations

1. **Immediately investigate** all High Priority CVEs
2. **Verify exploitability** in your specific context
3. **Prioritize patching** based on exploitability and impact
4. **Monitor** for new exploits on remaining CVEs
"""

        return report


def main():
    print("=" * 50)
    print("Exploit-DB Cross-Reference")
    print("=" * 50)

    checker = ExploitDBChecker()
    results = checker.check_all_cves()

    # Save JSON results
    output_file = Path(SCAN_DIR) / "exploitdb_results.json"
    with open(output_file, "w") as f:
        json.dump(results, f, indent=2)

    # Generate markdown report
    report = checker.generate_exploitability_report(results)
    report_file = Path(SCAN_DIR) / "EXPLOITABILITY_REPORT.md"
    with open(report_file, "w") as f:
        f.write(report)

    print(f"\n[+] Exploit-DB check complete!")
    print(f"    CVEs Checked: {results['total_cves_checked']}")
    print(f"    Exploitable CVEs: {results['exploitable_cves']}")
    print(f"    High Priority: {len(results['summary']['high_priority'])}")
    print(f"    Output: {output_file}")
    print(f"    Report: {report_file}")


if __name__ == "__main__":
    main()
