#!/usr/bin/env python3
"""
Remediation recommendation engine that provides specific fixes for findings.
"""

import json
from typing import Dict, List
from pathlib import Path
import os

SCAN_DIR = os.environ.get("SCAN_DIR", "/app/results")

# Remediation database
REMEDIATIONS = {
    "SQL Injection": {
        "description": "SQL Injection allows attackers to execute arbitrary SQL commands.",
        "fix": """
1. Use parameterized queries/prepared statements
2. Use ORM methods instead of raw SQL
3. Validate and sanitize all user inputs
4. Implement least privilege database access

Example fix for SQLAlchemy:
```python
# Bad
db.execute(f"SELECT * FROM users WHERE id = {user_id}")

# Good
db.query(User).filter(User.id == user_id).first()
```
""",
        "references": [
            "https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html"
        ]
    },
    "JWT": {
        "description": "JWT vulnerabilities can lead to authentication bypass.",
        "fix": """
1. Always specify the algorithm explicitly
2. Use strong secrets (256-bit minimum)
3. Validate all JWT claims
4. Set appropriate expiration times
5. Never accept 'none' algorithm

Example fix:
```python
# Bad
jwt.decode(token, secret)

# Good
jwt.decode(token, secret, algorithms=["HS256"])
```
""",
        "references": [
            "https://cheatsheetseries.owasp.org/cheatsheets/JSON_Web_Token_for_Java_Cheat_Sheet.html"
        ]
    },
    "XSS": {
        "description": "Cross-Site Scripting allows injection of malicious scripts.",
        "fix": """
1. Sanitize all user input before rendering
2. Use Content-Security-Policy headers
3. Use DOMPurify for HTML sanitization
4. Avoid dangerouslySetInnerHTML

Example fix:
```typescript
// Bad
<div dangerouslySetInnerHTML={{ __html: userInput }} />

// Good
import DOMPurify from 'dompurify';
<div dangerouslySetInnerHTML={{ __html: DOMPurify.sanitize(userInput) }} />
```
""",
        "references": [
            "https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html"
        ]
    },
    "IDOR": {
        "description": "Insecure Direct Object Reference allows unauthorized access.",
        "fix": """
1. Implement authorization checks on all endpoints
2. Verify the user has access to the requested resource
3. Use indirect references (GUIDs instead of sequential IDs)
4. Log and monitor access attempts

Example fix:
```python
@router.get("/ideas/{idea_id}")
def get_idea(idea_id: int, user: User = Depends(get_current_user)):
    idea = IdeaService.get_by_id(db, idea_id)
    if idea.user_id != user.id and not user.is_admin:
        raise PermissionDeniedException("Access denied")
    return idea
```
""",
        "references": [
            "https://cheatsheetseries.owasp.org/cheatsheets/Insecure_Direct_Object_Reference_Prevention_Cheat_Sheet.html"
        ]
    },
    "Rate Limiting": {
        "description": "Missing or bypassable rate limiting enables brute force attacks.",
        "fix": """
1. Implement rate limiting on all sensitive endpoints
2. Use a distributed rate limiter (Redis)
3. Rate limit by IP and user ID
4. Implement exponential backoff

Example fix with SlowAPI:
```python
from slowapi import Limiter
from slowapi.util import get_remote_address

limiter = Limiter(key_func=get_remote_address)

@router.post("/auth/login")
@limiter.limit("5/minute")
def login(request: Request, ...):
    ...
```
""",
        "references": [
            "https://cheatsheetseries.owasp.org/cheatsheets/Denial_of_Service_Cheat_Sheet.html"
        ]
    },
    "CORS": {
        "description": "CORS misconfiguration can enable cross-origin attacks.",
        "fix": """
1. Never use allow_origins=["*"] with credentials
2. Explicitly list allowed origins
3. Restrict allowed methods and headers

Example fix:
```python
# Bad
CORSMiddleware(
    allow_origins=["*"],
    allow_credentials=True,
)

# Good
CORSMiddleware(
    allow_origins=["https://yourdomain.com"],
    allow_credentials=True,
    allow_methods=["GET", "POST"],
    allow_headers=["Authorization", "Content-Type"],
)
```
""",
        "references": [
            "https://cheatsheetseries.owasp.org/cheatsheets/Cross-Origin_Resource_Sharing_Cheat_Sheet.html"
        ]
    },
    "Hardcoded Secrets": {
        "description": "Hardcoded secrets can be extracted from source code.",
        "fix": """
1. Use environment variables for all secrets
2. Use a secrets manager (AWS Secrets Manager, HashiCorp Vault)
3. Never commit secrets to version control
4. Rotate secrets regularly

Example fix:
```python
# Bad
SECRET_KEY = "hardcoded-secret-value"  # pragma: allowlist secret

# Good
import os
SECRET_KEY = os.environ.get("SECRET_KEY")
if not SECRET_KEY:
    raise ValueError("SECRET_KEY environment variable required")
```
""",
        "references": [
            "https://cheatsheetseries.owasp.org/cheatsheets/Secrets_Management_Cheat_Sheet.html"
        ]
    }
}


def get_remediation(finding: Dict) -> Dict:
    """Get specific remediation for a finding."""
    # Match finding to remediation database
    title = finding.get("title", "").lower()
    category = finding.get("category", "").lower()
    description = finding.get("description", "").lower()

    for key, remediation in REMEDIATIONS.items():
        if key.lower() in title or key.lower() in category or key.lower() in description:
            return {
                "matched_category": key,
                **remediation
            }

    # Generic remediation
    return {
        "matched_category": "General",
        "description": "Security issue identified",
        "fix": finding.get("remediation", "Review and address the identified issue"),
        "references": finding.get("references", [])
    }


def enrich_with_remediations(findings_file: str) -> str:
    """Enrich findings with detailed remediations."""
    with open(findings_file, "r") as f:
        data = json.load(f)

    for finding in data.get("findings", []):
        remediation = get_remediation(finding)
        finding["detailed_remediation"] = remediation

    output_file = Path(findings_file).parent / "findings_with_remediations.json"
    with open(output_file, "w") as f:
        json.dump(data, f, indent=2)

    return str(output_file)


def main():
    findings_file = Path(SCAN_DIR) / "enriched_findings.json"
    if not findings_file.exists():
        findings_file = Path(SCAN_DIR) / "aggregated_findings.json"

    if not findings_file.exists():
        print("No findings file found")
        return

    output = enrich_with_remediations(str(findings_file))
    print(f"Enriched findings with remediations: {output}")


if __name__ == "__main__":
    main()
