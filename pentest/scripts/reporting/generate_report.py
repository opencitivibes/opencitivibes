#!/usr/bin/env python3
"""
Comprehensive report generator for penetration testing results.
Generates PDF, HTML, JSON, and CSV reports.

Usage:
    python generate_report.py --scan-dir /app/results/20260102_105341

IMPORTANT: Always specify --scan-dir to use the correct scan's aggregated findings.
"""

import argparse
import json
import os
import csv
from datetime import datetime
from pathlib import Path
from typing import Dict, List
from jinja2 import Template


class ReportGenerator:
    def __init__(self, findings_file: str):
        self.findings_file = Path(findings_file)
        self.output_dir = self.findings_file.parent / "reports"
        self.output_dir.mkdir(parents=True, exist_ok=True)

        with open(self.findings_file, "r") as f:
            self.data = json.load(f)

    def generate_html(self) -> str:
        """Generate HTML report."""
        template = Template('''
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OpenCitiVibes Security Assessment Report</title>
    <style>
        :root {
            --critical: #dc3545;
            --high: #fd7e14;
            --medium: #ffc107;
            --low: #28a745;
            --info: #17a2b8;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            line-height: 1.6;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background: #f5f5f5;
        }
        .header {
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            color: white;
            padding: 40px;
            border-radius: 10px;
            margin-bottom: 30px;
        }
        .header h1 { margin: 0; font-size: 2.5em; }
        .header .subtitle { opacity: 0.8; margin-top: 10px; }
        .summary-cards {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        .card {
            background: white;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .card.critical { border-left: 5px solid var(--critical); }
        .card.high { border-left: 5px solid var(--high); }
        .card.medium { border-left: 5px solid var(--medium); }
        .card.low { border-left: 5px solid var(--low); }
        .card .number { font-size: 3em; font-weight: bold; }
        .card .label { color: #666; }
        .finding {
            background: white;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .finding-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }
        .finding-title { font-size: 1.3em; font-weight: bold; margin: 0; }
        .severity-badge {
            padding: 5px 15px;
            border-radius: 20px;
            color: white;
            font-weight: bold;
            font-size: 0.9em;
        }
        .severity-critical { background: var(--critical); }
        .severity-high { background: var(--high); }
        .severity-medium { background: var(--medium); }
        .severity-low { background: var(--low); }
        .severity-info { background: var(--info); }
        .finding-meta { color: #666; font-size: 0.9em; margin-bottom: 15px; }
        .section-title { font-weight: bold; margin-top: 15px; color: #333; }
        .code-block {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 5px;
            font-family: monospace;
            overflow-x: auto;
        }
        .remediation {
            background: #e8f5e9;
            padding: 15px;
            border-radius: 5px;
            border-left: 4px solid #4caf50;
        }
        .toc {
            background: white;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 30px;
        }
        .toc ul { list-style: none; padding-left: 0; }
        .toc li { padding: 5px 0; }
        .toc a { color: #16213e; text-decoration: none; }
        .toc a:hover { text-decoration: underline; }
        @media print {
            body { background: white; }
            .finding { break-inside: avoid; }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>Security Assessment Report</h1>
        <div class="subtitle">OpenCitiVibes Application</div>
        <div class="subtitle">Generated: {{ scan_date }}</div>
    </div>

    <div class="summary-cards">
        <div class="card critical">
            <div class="number">{{ by_severity.CRITICAL }}</div>
            <div class="label">Critical</div>
        </div>
        <div class="card high">
            <div class="number">{{ by_severity.HIGH }}</div>
            <div class="label">High</div>
        </div>
        <div class="card medium">
            <div class="number">{{ by_severity.MEDIUM }}</div>
            <div class="label">Medium</div>
        </div>
        <div class="card low">
            <div class="number">{{ by_severity.LOW }}</div>
            <div class="label">Low</div>
        </div>
    </div>

    <div class="card">
        <h2>Executive Summary</h2>
        <p>This report presents the findings from a comprehensive security assessment of the OpenCitiVibes application.
        A total of <strong>{{ total_findings }}</strong> security findings were identified across various severity levels.</p>

        <p><strong>Key Observations:</strong></p>
        <ul>
            {% if by_severity.CRITICAL > 0 %}
            <li>{{ by_severity.CRITICAL }} critical vulnerabilities require immediate attention</li>
            {% endif %}
            {% if by_severity.HIGH > 0 %}
            <li>{{ by_severity.HIGH }} high-severity issues should be addressed in the short term</li>
            {% endif %}
            <li>The assessment covered authentication, authorization, injection vulnerabilities, and configuration security</li>
        </ul>
    </div>

    <div class="toc">
        <h2>Table of Contents</h2>
        <ul>
            {% for finding in findings %}
            <li><a href="#{{ finding.id }}">{{ finding.id }}: {{ finding.title }}</a></li>
            {% endfor %}
        </ul>
    </div>

    <h2>Detailed Findings</h2>

    {% for finding in findings %}
    <div class="finding" id="{{ finding.id }}">
        <div class="finding-header">
            <h3 class="finding-title">{{ finding.id }}: {{ finding.title }}</h3>
            <span class="severity-badge severity-{{ finding.severity|lower }}">{{ finding.severity }}</span>
        </div>

        <div class="finding-meta">
            <strong>Category:</strong> {{ finding.category }} |
            <strong>Component:</strong> {{ finding.affected_component }} |
            <strong>Source:</strong> {{ finding.source_tool }}
            {% if finding.cwe_id %}| <strong>CWE:</strong> {{ finding.cwe_id }}{% endif %}
        </div>

        <div class="section-title">Description</div>
        <p>{{ finding.description }}</p>

        {% if finding.reproduction_steps %}
        <div class="section-title">Reproduction Steps</div>
        <div class="code-block">
            {% for step in finding.reproduction_steps %}
            <div>{{ step }}</div>
            {% endfor %}
        </div>
        {% endif %}

        {% if finding.evidence %}
        <div class="section-title">Evidence</div>
        <div class="code-block">
            {% for evidence in finding.evidence %}
            <div>{{ evidence }}</div>
            {% endfor %}
        </div>
        {% endif %}

        <div class="section-title">Remediation</div>
        <div class="remediation">
            {{ finding.remediation }}
        </div>

        {% if finding.references %}
        <div class="section-title">References</div>
        <ul>
            {% for ref in finding.references %}
            <li><a href="{{ ref }}" target="_blank">{{ ref }}</a></li>
            {% endfor %}
        </ul>
        {% endif %}
    </div>
    {% endfor %}

    <div class="card">
        <h2>Methodology</h2>
        <p>This assessment was conducted using a combination of automated scanning tools and manual testing techniques:</p>
        <ul>
            <li><strong>Static Analysis:</strong> Bandit, Semgrep, ESLint Security</li>
            <li><strong>Dynamic Analysis:</strong> OWASP ZAP, Nuclei</li>
            <li><strong>Manual Testing:</strong> JWT testing, IDOR testing, SQL injection testing</li>
            <li><strong>Dependency Analysis:</strong> pip-audit, pnpm audit</li>
            <li><strong>Container Security:</strong> Trivy, Grype</li>
        </ul>
    </div>

    <footer style="text-align: center; margin-top: 40px; color: #666;">
        <p>Generated by OpenCitiVibes Penetration Testing Framework</p>
        <p>{{ scan_date }}</p>
    </footer>
</body>
</html>
        ''')

        html = template.render(**self.data)
        output_file = self.output_dir / "security_report.html"
        with open(output_file, "w") as f:
            f.write(html)

        return str(output_file)

    def generate_csv(self) -> str:
        """Generate CSV report."""
        output_file = self.output_dir / "findings.csv"

        with open(output_file, "w", newline="") as f:
            writer = csv.writer(f)
            writer.writerow([
                "ID", "Severity", "Title", "Category", "Component",
                "CWE", "Description", "Remediation", "Source Tool"
            ])

            for finding in self.data.get("findings", []):
                writer.writerow([
                    finding.get("id", ""),
                    finding.get("severity", ""),
                    finding.get("title", ""),
                    finding.get("category", ""),
                    finding.get("affected_component", ""),
                    finding.get("cwe_id", ""),
                    finding.get("description", "")[:200],
                    finding.get("remediation", "")[:200],
                    finding.get("source_tool", "")
                ])

        return str(output_file)

    def generate_json(self) -> str:
        """Generate JSON report."""
        output_file = self.output_dir / "findings.json"
        with open(output_file, "w") as f:
            json.dump(self.data, f, indent=2)
        return str(output_file)

    def generate_executive_summary(self) -> str:
        """Generate executive summary with detailed findings breakdown."""
        summary = f"""# Executive Summary: Security Assessment

## OpenCitiVibes Application

**Assessment Date:** {self.data.get('scan_date', 'N/A')}

---

## Overview

A comprehensive security assessment was conducted on the OpenCitiVibes application. This assessment included static code analysis, dynamic application security testing, and manual penetration testing.

## Key Findings

| Severity | Count |
|----------|-------|
| Critical | {self.data['by_severity']['CRITICAL']} |
| High     | {self.data['by_severity']['HIGH']} |
| Medium   | {self.data['by_severity']['MEDIUM']} |
| Low      | {self.data['by_severity']['LOW']} |
| Info     | {self.data['by_severity']['INFO']} |

**Total Findings:** {self.data['total_findings']}

## Risk Assessment

"""
        if self.data['by_severity']['CRITICAL'] > 0:
            summary += """### CRITICAL RISK
Critical vulnerabilities were identified that require immediate attention. These issues could potentially lead to complete system compromise.

"""

        if self.data['by_severity']['HIGH'] > 0:
            summary += """### HIGH RISK
High-severity vulnerabilities were found that should be addressed as a priority. These could allow unauthorized access or data exposure.

"""

        if self.data['by_severity']['CRITICAL'] == 0 and self.data['by_severity']['HIGH'] == 0:
            summary += """### LOW RISK
No critical or high severity vulnerabilities were found. The application has a good security posture.

"""

        summary += """## Recommendations

1. **Immediate Actions:**
   - Address all Critical and High severity findings
   - Review authentication and authorization controls
   - Update dependencies with known vulnerabilities

2. **Short-term Actions:**
   - Implement security headers across all responses
   - Add rate limiting to sensitive endpoints
   - Enhance input validation

3. **Long-term Actions:**
   - Establish a security review process for code changes
   - Implement continuous security testing in CI/CD
   - Conduct regular penetration testing

---

## Detailed Findings by Severity

"""
        # Group findings by severity
        findings = self.data.get('findings', [])

        for severity in ['CRITICAL', 'HIGH', 'MEDIUM', 'LOW', 'INFO']:
            severity_findings = [f for f in findings if f.get('severity', '').upper() == severity]
            count = len(severity_findings)

            if count == 0:
                continue

            # Severity header with emoji
            emoji = {'CRITICAL': 'ðŸ”´', 'HIGH': 'ðŸŸ ', 'MEDIUM': 'ðŸŸ¡', 'LOW': 'ðŸŸ¢', 'INFO': 'ðŸ”µ'}.get(severity, '')
            summary += f"### {emoji} {severity} Severity ({count} findings)\n\n"

            # Group by category/source for better organization
            by_source = {}
            for f in severity_findings:
                source = f.get('source_tool', 'Unknown')
                if source not in by_source:
                    by_source[source] = []
                by_source[source].append(f)

            for source, source_findings in by_source.items():
                summary += f"#### Source: {source} ({len(source_findings)} findings)\n\n"

                # Show top findings (limit to avoid huge reports)
                max_to_show = 10 if severity in ['CRITICAL', 'HIGH'] else 5
                shown = 0

                # Deduplicate by title for cleaner output
                seen_titles = set()
                for f in source_findings:
                    title = f.get('title', 'Unknown')
                    if title in seen_titles:
                        continue
                    seen_titles.add(title)

                    if shown >= max_to_show:
                        remaining = len(source_findings) - shown
                        if remaining > 0:
                            summary += f"  - *... and {remaining} more similar findings*\n"
                        break

                    component = f.get('affected_component', 'N/A')
                    # Truncate long components
                    if len(component) > 60:
                        component = component[:57] + "..."

                    summary += f"  - **{title}**\n"
                    summary += f"    - Component: `{component}`\n"

                    # Add remediation for critical/high
                    if severity in ['CRITICAL', 'HIGH']:
                        remediation = f.get('remediation', 'See detailed report')
                        if len(remediation) > 100:
                            remediation = remediation[:97] + "..."
                        summary += f"    - Remediation: {remediation}\n"

                    # Add CVE/CWE if present
                    cwe = f.get('cwe_id')
                    if cwe:
                        summary += f"    - Reference: {cwe}\n"

                    shown += 1

                summary += "\n"

        summary += """---

## Conclusion

This assessment identified security weaknesses that should be addressed to improve the overall security posture of the application. The development team should prioritize remediation based on the severity ratings provided.

For full details on each finding, including evidence and reproduction steps, please refer to:
- `findings.json` - Machine-readable format
- `findings.csv` - Spreadsheet format
- `security_report.html` - Interactive HTML report

---

*This report was generated automatically by the OpenCitiVibes Penetration Testing Framework.*
"""

        output_file = self.output_dir / "EXECUTIVE_SUMMARY.md"
        with open(output_file, "w") as f:
            f.write(summary)

        return str(output_file)

    def generate_all(self) -> Dict[str, str]:
        """Generate all report formats."""
        return {
            "html": self.generate_html(),
            "csv": self.generate_csv(),
            "json": self.generate_json(),
            "executive_summary": self.generate_executive_summary(),
            "ci_summary": self.generate_ci_summary()
        }

    def generate_ci_summary(self) -> str:
        """Generate JSON summary for CI tools."""
        # Load additional metadata if available
        metadata = {
            "scan_id": os.environ.get("SCAN_ID", "unknown"),
            "playwright_urls": 0,
            "schemathesis_failures": 0,
            "schemathesis_tests": 0
        }

        # Try to load Playwright discovered URLs
        urls_file = self.output_dir.parent / "recon" / "playwright-urls.txt"
        if urls_file.exists():
            try:
                urls = urls_file.read_text().strip().split('\n')
                metadata["playwright_urls"] = len([u for u in urls if u])
            except Exception:
                pass

        # Try to load Schemathesis results
        schema_log = self.output_dir.parent / "schemathesis" / "output.log"
        if schema_log.exists():
            try:
                content = schema_log.read_text()
                metadata["schemathesis_failures"] = content.count("FAILED")
                metadata["schemathesis_tests"] = content.count("PASSED") + content.count("FAILED")
            except Exception:
                pass

        # Count KEV findings
        kev_count = sum(
            1 for f in self.data.get("findings", [])
            if f.get("title", "").startswith("[KEV]") or f.get("is_kev")
        )

        summary = {
            "scan_id": metadata["scan_id"],
            "timestamp": self.data.get("scan_date", datetime.now().isoformat()),
            "total_findings": self.data.get("total_findings", 0),
            "by_severity": {
                "CRITICAL": self.data["by_severity"].get("CRITICAL", 0),
                "HIGH": self.data["by_severity"].get("HIGH", 0),
                "MEDIUM": self.data["by_severity"].get("MEDIUM", 0),
                "LOW": self.data["by_severity"].get("LOW", 0),
                "INFO": self.data["by_severity"].get("INFO", 0)
            },
            "kev_count": kev_count,
            "playwright_urls": metadata["playwright_urls"],
            "schemathesis": {
                "tests": metadata["schemathesis_tests"],
                "failures": metadata["schemathesis_failures"]
            },
            "sources": list(set(
                f.get("source_tool", "Unknown")
                for f in self.data.get("findings", [])
            )),
            "exit_code": self._calculate_exit_code()
        }

        output_file = self.output_dir / "SUMMARY.json"
        with open(output_file, "w") as f:
            json.dump(summary, f, indent=2)

        return str(output_file)

    def _calculate_exit_code(self) -> int:
        """Calculate appropriate exit code for CI based on findings."""
        criticals = self.data["by_severity"].get("CRITICAL", 0)
        highs = self.data["by_severity"].get("HIGH", 0)

        # Check for KEV findings (should always be critical)
        kev_count = sum(
            1 for f in self.data.get("findings", [])
            if f.get("title", "").startswith("[KEV]") or f.get("is_kev")
        )

        if kev_count > 0 or criticals > 0:
            return 2  # Critical - must fix
        elif highs > 5:
            return 1  # Warning - should fix
        else:
            return 0  # OK


def main():
    parser = argparse.ArgumentParser(
        description="Generate security assessment reports from aggregated findings.",
        epilog="IMPORTANT: Always specify --scan-dir to use the correct scan's findings."
    )
    parser.add_argument(
        "--scan-dir",
        required=True,
        help="Path to the specific scan directory (e.g., /app/results/20260102_105341)"
    )
    parser.add_argument(
        "--format",
        choices=["all", "html", "csv", "json", "text"],
        default="all",
        help="Output format (default: all)"
    )
    args = parser.parse_args()

    scan_dir = Path(args.scan_dir)
    if not scan_dir.exists():
        print(f"Error: Scan directory not found: {scan_dir}")
        return 1

    # Validate it's a specific scan directory, not the parent results folder
    if scan_dir.name == "results":
        print("Error: Please specify a specific scan directory, not /app/results")
        print("Example: --scan-dir /app/results/20260102_105341")
        return 1

    # Look for enriched findings first, then aggregated
    findings_file = scan_dir / "enriched_findings.json"
    if not findings_file.exists():
        findings_file = scan_dir / "aggregated_findings.json"

    if not findings_file.exists():
        print("No findings file found. Run aggregate_findings.py first.")
        print(f"Expected: {scan_dir}/aggregated_findings.json")
        return 1

    generator = ReportGenerator(str(findings_file))
    reports = generator.generate_all()

    print("Generated reports:")
    for format_name, path in reports.items():
        print(f"  {format_name}: {path}")

    return 0


if __name__ == "__main__":
    exit(main() or 0)
