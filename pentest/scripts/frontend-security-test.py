#!/usr/bin/env python3
"""
Frontend Security Testing for Next.js Applications.
Tests for XSS, CSRF, cookie security, and client-side vulnerabilities.

OpenCitiVibes Penetration Testing - Phase 3
"""

import argparse
import json
import os
import sys
from pathlib import Path
from datetime import datetime
from urllib.parse import urljoin, urlparse

# Try playwright, fall back to requests
try:
    from playwright.sync_api import sync_playwright
    HAS_PLAYWRIGHT = True
except ImportError:
    HAS_PLAYWRIGHT = False

try:
    import requests
    HAS_REQUESTS = True
except ImportError:
    HAS_REQUESTS = False

SCAN_DIR = Path(os.environ.get("SCAN_DIR", "/app/results"))


class FrontendSecurityTester:
    """Frontend security testing suite for SPAs."""

    def __init__(self, base_url: str, output_dir: Path):
        self.base_url = base_url
        self.output_dir = output_dir
        self.output_dir.mkdir(parents=True, exist_ok=True)
        self.findings = []

    def log(self, message: str, level: str = "INFO"):
        """Log message with timestamp."""
        prefix = {"INFO": "[*]", "SUCCESS": "[+]", "WARNING": "[!]", "ERROR": "[-]", "CRITICAL": "[!!!]"}
        print(f"{prefix.get(level, '[*]')} {message}")

    def add_finding(self, title: str, severity: str, description: str,
                    evidence: str = "", remediation: str = ""):
        """Add a security finding."""
        self.findings.append({
            "title": title,
            "severity": severity,
            "description": description,
            "evidence": evidence,
            "remediation": remediation,
            "url": self.base_url,
            "timestamp": datetime.now().isoformat()
        })

    def test_security_headers(self):
        """Test for security headers on main page."""
        self.log("Testing security headers...")

        headers = {}
        if HAS_PLAYWRIGHT:
            try:
                with sync_playwright() as p:
                    browser = p.chromium.launch(headless=True)
                    page = browser.new_page()
                    response = page.goto(self.base_url)
                    if response:
                        headers = dict(response.headers)
                    browser.close()
            except Exception as e:
                self.log(f"Playwright error: {e}", "WARNING")
        elif HAS_REQUESTS:
            try:
                response = requests.get(self.base_url, timeout=30)
                headers = dict(response.headers)
            except Exception as e:
                self.log(f"Request error: {e}", "ERROR")
                return

        if not headers:
            self.log("Could not retrieve headers", "WARNING")
            return

        required_headers = {
            "strict-transport-security": {
                "name": "HSTS",
                "severity": "MEDIUM",
                "remediation": "Add Strict-Transport-Security header with max-age=31536000"
            },
            "x-content-type-options": {
                "name": "X-Content-Type-Options",
                "severity": "LOW",
                "remediation": "Add X-Content-Type-Options: nosniff"
            },
            "x-frame-options": {
                "name": "X-Frame-Options",
                "severity": "MEDIUM",
                "remediation": "Add X-Frame-Options: DENY or SAMEORIGIN"
            },
            "content-security-policy": {
                "name": "CSP",
                "severity": "MEDIUM",
                "remediation": "Implement Content-Security-Policy header"
            },
            "referrer-policy": {
                "name": "Referrer-Policy",
                "severity": "LOW",
                "remediation": "Add Referrer-Policy: strict-origin-when-cross-origin"
            },
            "permissions-policy": {
                "name": "Permissions-Policy",
                "severity": "LOW",
                "remediation": "Add Permissions-Policy to restrict browser features"
            }
        }

        headers_lower = {k.lower(): v for k, v in headers.items()}

        for header, config in required_headers.items():
            if header not in headers_lower:
                self.add_finding(
                    f"Missing {config['name']} Header",
                    config["severity"],
                    f"The {config['name']} security header is not present.",
                    f"Headers received: {', '.join(list(headers.keys())[:10])}",
                    config["remediation"]
                )
            else:
                self.log(f"  Found: {config['name']}: {headers_lower[header][:50]}...")

    def test_cookie_security(self):
        """Test cookie security attributes."""
        self.log("Testing cookie security...")

        if not HAS_PLAYWRIGHT:
            self.log("Skipping (requires Playwright)", "WARNING")
            return

        try:
            with sync_playwright() as p:
                browser = p.chromium.launch(headless=True)
                context = browser.new_context()
                page = context.new_page()
                page.goto(self.base_url)

                # Try to trigger login to get auth cookies
                try:
                    page.goto(urljoin(self.base_url, "/login"))
                    page.wait_for_timeout(1000)
                except:
                    pass

                cookies = context.cookies()
                browser.close()
        except Exception as e:
            self.log(f"Error getting cookies: {e}", "ERROR")
            return

        for cookie in cookies:
            issues = []

            if not cookie.get("secure", False):
                issues.append("Secure flag not set")

            if not cookie.get("httpOnly", False):
                name_lower = cookie.get("name", "").lower()
                if any(term in name_lower for term in ["token", "jwt", "auth", "session", "sid"]):
                    issues.append("HttpOnly flag not set on sensitive cookie")

            same_site = cookie.get("sameSite", "")
            if same_site not in ["Strict", "Lax"]:
                issues.append(f"SameSite={same_site} (should be Strict or Lax)")

            if issues:
                name_lower = cookie.get("name", "").lower()
                is_sensitive = any(term in name_lower for term in ["token", "jwt", "auth", "session", "sid"])
                self.add_finding(
                    f"Insecure Cookie: {cookie.get('name')}",
                    "MEDIUM" if is_sensitive else "LOW",
                    f"Cookie security issues: {', '.join(issues)}",
                    f"Cookie name: {cookie.get('name')}, Domain: {cookie.get('domain')}",
                    "Set Secure, HttpOnly, and SameSite attributes on sensitive cookies"
                )

    def test_javascript_security(self):
        """Test for dangerous JavaScript patterns."""
        self.log("Testing JavaScript security...")

        if not HAS_PLAYWRIGHT:
            self.log("Skipping (requires Playwright)", "WARNING")
            return

        try:
            with sync_playwright() as p:
                browser = p.chromium.launch(headless=True)
                page = browser.new_page()

                # Capture console messages
                console_messages = []
                page.on("console", lambda msg: console_messages.append(msg.text))

                page.goto(self.base_url)
                page.wait_for_timeout(2000)

                # Check for inline scripts
                inline_scripts = page.evaluate("""
                    () => {
                        const scripts = document.querySelectorAll('script:not([src])');
                        return Array.from(scripts).map(s => s.innerHTML.substring(0, 200));
                    }
                """)

                # Check localStorage for sensitive data
                local_storage = page.evaluate("""
                    () => {
                        const items = {};
                        for (let i = 0; i < localStorage.length; i++) {
                            const key = localStorage.key(i);
                            items[key] = localStorage.getItem(key).substring(0, 100);
                        }
                        return items;
                    }
                """)

                # Check sessionStorage
                session_storage = page.evaluate("""
                    () => {
                        const items = {};
                        for (let i = 0; i < sessionStorage.length; i++) {
                            const key = sessionStorage.key(i);
                            items[key] = sessionStorage.getItem(key).substring(0, 100);
                        }
                        return items;
                    }
                """)

                browser.close()

        except Exception as e:
            self.log(f"Error testing JavaScript: {e}", "ERROR")
            return

        # Check for tokens in localStorage
        for key, value in local_storage.items():
            if any(term in key.lower() for term in ["token", "jwt", "auth", "session", "access"]):
                self.add_finding(
                    f"Sensitive Data in localStorage: {key}",
                    "MEDIUM",
                    "Authentication tokens stored in localStorage are vulnerable to XSS attacks.",
                    f"Key: {key}, Value: {value[:50]}...",
                    "Consider using httpOnly cookies for token storage"
                )

        # Report inline scripts (potential CSP issue)
        if inline_scripts:
            self.add_finding(
                "Inline JavaScript Detected",
                "INFO",
                f"Found {len(inline_scripts)} inline script(s). May indicate CSP issues.",
                f"First script: {inline_scripts[0][:100] if inline_scripts else 'N/A'}...",
                "Use external scripts or CSP nonce/hash for inline scripts"
            )

    def test_xss_reflection(self):
        """Test for reflected XSS in URL parameters."""
        self.log("Testing XSS reflection points...")

        payloads = [
            ("<script>alert(1)</script>", "script tag"),
            ("javascript:alert(1)", "javascript protocol"),
            ("<img src=x onerror=alert(1)>", "img onerror"),
            ("{{7*7}}", "template injection"),
            ("${7*7}", "expression injection"),
        ]

        test_params = ["q", "search", "query", "id", "name", "redirect", "url", "next", "return", "callback"]

        if HAS_PLAYWRIGHT:
            try:
                with sync_playwright() as p:
                    browser = p.chromium.launch(headless=True)
                    page = browser.new_page()

                    for param in test_params:
                        for payload, name in payloads:
                            test_url = f"{self.base_url}?{param}={payload}"
                            try:
                                response = page.goto(test_url, timeout=5000)
                                if not response:
                                    continue
                                content = page.content()

                                # Check if payload is reflected unescaped
                                if payload in content:
                                    # Check if it's properly escaped
                                    escaped = f"&lt;{payload[1:]}" if payload.startswith("<") else None
                                    if escaped and escaped in content:
                                        continue  # Properly escaped

                                    self.add_finding(
                                        f"Potential XSS: {param} parameter",
                                        "HIGH",
                                        f"The {name} payload was reflected without encoding.",
                                        f"URL: {test_url}",
                                        "Encode all user input before rendering"
                                    )
                                    break
                            except:
                                continue

                    browser.close()
            except Exception as e:
                self.log(f"Error testing XSS: {e}", "ERROR")

    def test_open_redirect(self):
        """Test for open redirect vulnerabilities."""
        self.log("Testing open redirect...")

        redirect_params = ["redirect", "url", "next", "return", "returnUrl", "returnTo", "goto", "dest", "destination"]
        external_url = "https://evil.example.com"

        if HAS_REQUESTS:
            for param in redirect_params:
                test_url = f"{self.base_url}/login?{param}={external_url}"
                try:
                    response = requests.get(test_url, allow_redirects=False, timeout=10)
                    location = response.headers.get("Location", "")

                    if external_url in location or "evil.example.com" in location:
                        self.add_finding(
                            f"Open Redirect: {param} parameter",
                            "MEDIUM",
                            f"The application redirects to external URLs via {param} parameter.",
                            f"Test URL: {test_url}\nLocation: {location}",
                            "Validate redirect URLs against an allowlist"
                        )
                except:
                    continue

    def run_all_tests(self):
        """Run all frontend security tests."""
        self.log(f"\nFrontend Security Testing: {self.base_url}")
        self.log("=" * 60)

        self.test_security_headers()
        self.test_cookie_security()
        self.test_javascript_security()
        self.test_xss_reflection()
        self.test_open_redirect()

        # Save results
        output_file = self.output_dir / "frontend-security.json"
        with open(output_file, "w") as f:
            json.dump({
                "target": self.base_url,
                "scan_date": datetime.now().isoformat(),
                "total_findings": len(self.findings),
                "by_severity": {
                    "CRITICAL": len([f for f in self.findings if f["severity"] == "CRITICAL"]),
                    "HIGH": len([f for f in self.findings if f["severity"] == "HIGH"]),
                    "MEDIUM": len([f for f in self.findings if f["severity"] == "MEDIUM"]),
                    "LOW": len([f for f in self.findings if f["severity"] == "LOW"]),
                    "INFO": len([f for f in self.findings if f["severity"] == "INFO"]),
                },
                "findings": self.findings
            }, f, indent=2)

        self.log(f"\n[+] Testing complete. Found {len(self.findings)} issues.")
        self.log(f"[+] Results saved to: {output_file}")

        # Print summary
        for sev in ["CRITICAL", "HIGH", "MEDIUM", "LOW", "INFO"]:
            count = len([f for f in self.findings if f["severity"] == sev])
            if count > 0:
                self.log(f"    {sev}: {count}")

        return self.findings


def main():
    parser = argparse.ArgumentParser(description="Frontend Security Tester")
    parser.add_argument("--url", default=os.environ.get("TARGET_FRONTEND", "http://frontend:3000"),
                        help="Target frontend URL")
    parser.add_argument("--output", default=str(SCAN_DIR / "frontend"),
                        help="Output directory")
    args = parser.parse_args()

    tester = FrontendSecurityTester(args.url, Path(args.output))
    tester.run_all_tests()


if __name__ == "__main__":
    main()
