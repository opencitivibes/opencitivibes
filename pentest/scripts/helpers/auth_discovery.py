#!/usr/bin/env python3
"""
Authentication Discovery Helper for OpenCitiVibes Pentest

Dynamically discovers and creates test accounts for the running instance.
No hardcoded credentials - works with any instance.
"""

import os
import sys
import time
import random
import string
import requests
from typing import Optional, Tuple, Dict, Any
from datetime import datetime

TARGET_API = os.environ.get("TARGET_API", "http://backend:8000/api")


def generate_random_string(length: int = 8) -> str:
    """Generate a random alphanumeric string."""
    return ''.join(random.choices(string.ascii_lowercase + string.digits, k=length))


def generate_test_password() -> str:
    """Generate a strong password for test accounts."""
    # Meets typical password requirements: upper, lower, digit, special, length >= 8
    return f"Test{generate_random_string(4)}!{random.randint(100, 999)}"


def wait_for_rate_limit(seconds: int = 60):
    """Wait for rate limit to clear."""
    print(f"[INFO] Waiting {seconds}s for rate limit to clear...")
    time.sleep(seconds)


def create_test_user(session: requests.Session) -> Tuple[Optional[str], Optional[str]]:
    """
    Create a new test user account for testing.
    Returns (email, password) tuple or (None, None) on failure.
    """
    timestamp = int(datetime.now().timestamp())
    email = f"pentest_{timestamp}_{generate_random_string(4)}@pentest-user.com"
    username = f"pentest_{timestamp}"
    password = generate_test_password()

    try:
        response = session.post(
            f"{TARGET_API}/auth/register",
            json={
                "email": email,
                "username": username,
                "display_name": f"Pentest User {timestamp}",
                "password": password
            },
            timeout=10
        )

        if response.status_code == 200:
            print(f"[SUCCESS] Created test user: {email}")
            return email, password
        elif response.status_code == 429:
            print(f"[WARNING] Rate limited during user creation")
            wait_for_rate_limit()
            return create_test_user(session)  # Retry
        else:
            print(f"[WARNING] Could not create test user: {response.status_code} - {response.text[:100]}")
            return None, None

    except Exception as e:
        print(f"[ERROR] Exception creating test user: {e}")
        return None, None


def get_token_for_credentials(session: requests.Session, email: str, password: str) -> Optional[str]:
    """Attempt to get a JWT token with given credentials."""
    try:
        response = session.post(
            f"{TARGET_API}/auth/login",
            data={"username": email, "password": password},
            timeout=10
        )

        if response.status_code == 200:
            token = response.json().get("access_token")
            if token:
                return token
        elif response.status_code == 429:
            wait_for_rate_limit()
            return get_token_for_credentials(session, email, password)

    except Exception as e:
        print(f"[ERROR] Exception during login: {e}")

    return None


def discover_admin_from_env() -> Tuple[Optional[str], Optional[str]]:
    """Try to get admin credentials from environment variables."""
    email = os.environ.get("ADMIN_EMAIL")
    password = os.environ.get("ADMIN_PASSWORD")

    if email and password:
        return email, password
    return None, None


def get_authenticated_session(
    require_admin: bool = False,
    max_retries: int = 3
) -> Tuple[requests.Session, Optional[str], Dict[str, Any]]:
    """
    Get an authenticated session for testing.

    Returns:
        Tuple of (session, token, user_info) where:
        - session: requests.Session with auth configured
        - token: JWT token string or None
        - user_info: dict with email, is_admin, etc. or empty dict

    Strategy:
    1. Try environment variable credentials first
    2. Create a new test user account
    3. Return unauthenticated session if all fails
    """
    session = requests.Session()
    user_info: Dict[str, Any] = {}

    # Strategy 1: Try environment credentials
    env_email, env_password = discover_admin_from_env()
    if env_email and env_password:
        print(f"[INFO] Trying environment credentials: {env_email}")
        token = get_token_for_credentials(session, env_email, env_password)
        if token:
            print(f"[SUCCESS] Authenticated as {env_email}")
            user_info = {
                "email": env_email,
                "is_admin": True,  # Assume env creds are admin
                "source": "environment"
            }
            return session, token, user_info
        else:
            print(f"[WARNING] Environment credentials failed")

    # Strategy 2: Create a test user
    print("[INFO] Creating test user for authentication...")
    test_email, test_password = create_test_user(session)
    if test_email and test_password:
        token = get_token_for_credentials(session, test_email, test_password)
        if token:
            print(f"[SUCCESS] Authenticated as test user {test_email}")
            user_info = {
                "email": test_email,
                "password": test_password,  # Store for IDOR tests needing multiple users
                "is_admin": False,
                "source": "created"
            }
            return session, token, user_info

    # Strategy 3: Return unauthenticated session
    print("[WARNING] Could not authenticate, returning unauthenticated session")
    return session, None, {}


def create_second_test_user(session: requests.Session) -> Tuple[Optional[str], Optional[str], Optional[str]]:
    """
    Create a second test user for IDOR testing (testing access to other users' resources).
    Returns (email, password, token) tuple.
    """
    email, password = create_test_user(session)
    if email and password:
        token = get_token_for_credentials(session, email, password)
        return email, password, token
    return None, None, None


def cleanup_message():
    """Print cleanup reminder."""
    print("\n[INFO] Note: Test users created during pentest should be cleaned up:")
    print("       DELETE FROM users WHERE email LIKE 'pentest_%@pentest-user.com';")


if __name__ == "__main__":
    # Test the discovery mechanism
    print("Testing authentication discovery...")
    session, token, user_info = get_authenticated_session()

    if token:
        print(f"\nAuthentication successful!")
        print(f"  Email: {user_info.get('email')}")
        print(f"  Admin: {user_info.get('is_admin')}")
        print(f"  Source: {user_info.get('source')}")
        print(f"  Token: {token[:50]}...")
    else:
        print("\nAuthentication failed - tests will run in limited mode")
