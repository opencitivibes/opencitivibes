#!/usr/bin/env python3
"""
Remediation Verification Testing Script for OpenCitiVibes

Retests all previously identified vulnerabilities to verify they have been fixed.
Produces a detailed remediation verification report.

Previous findings to verify:
1. HIGH: 5 Potential stored XSS vulnerabilities in ideas
2. LOW: 2167 Various low-severity findings (mostly assert statements)

Uses the API at localhost:8000.
"""

import requests
import json
import time
import base64
import hmac
import hashlib
from datetime import datetime
from pathlib import Path
from typing import Dict, List, Any, Optional, Tuple

# Configuration
TARGET_API = "http://127.0.0.1:8000/api"
# Use test user credentials (admin may not exist in test DB)
ADMIN_EMAIL = "pentest_retest@test.com"
ADMIN_PASSWORD = "Pentest123!@#"
RESULTS_DIR = Path("/home/matt/projects/IdeesPourMontreal/pentest/results/remediation")

# XSS payloads to test
XSS_PAYLOADS = [
    '<script>alert("XSS")</script>',
    '<img src=x onerror=alert("XSS")>',
    '<svg onload=alert("XSS")>',
    '"><script>alert("XSS")</script>',
    "javascript:alert('XSS')",
    '<a href="javascript:alert(1)">click</a>',
    '<body onload=alert("XSS")>',
    '{{constructor.constructor("alert(1)")()}}',
    '${alert("XSS")}',
    '<iframe src="javascript:alert(1)">',
]

# Weak JWT secrets to test
WEAK_SECRETS = [
    "secret",
    "password",
    "jwt_secret",
    "your-256-bit-secret",
    "your-secret-key",
    "supersecret",
    "development",
    "changeme",
    "qwerty123",
]


class RemediationTester:
    def __init__(self):
        self.results: List[Dict[str, Any]] = []
        self.session = requests.Session()
        self.token: Optional[str] = None
        self.user_info: Dict[str, Any] = {}

        RESULTS_DIR.mkdir(parents=True, exist_ok=True)

    def log(self, level: str, message: str, finding_id: str = "",
            status: str = "", evidence: str = ""):
        """Log a test result."""
        timestamp = datetime.now().isoformat()
        print(f"[{timestamp}] [{level}] {message}")

        self.results.append({
            "timestamp": timestamp,
            "level": level,
            "message": message,
            "finding_id": finding_id,
            "status": status,  # FIXED, STILL_VULNERABLE, INCONCLUSIVE
            "evidence": evidence
        })

    def authenticate(self) -> bool:
        """Get authentication token."""
        try:
            response = self.session.post(
                f"{TARGET_API}/auth/login",
                data={"username": ADMIN_EMAIL, "password": ADMIN_PASSWORD},
                timeout=10
            )

            if response.status_code == 200:
                self.token = response.json().get("access_token")
                self.user_info = {"email": ADMIN_EMAIL, "is_admin": True}
                self.log("INFO", f"Authenticated as {ADMIN_EMAIL}")
                return True
            else:
                self.log("ERROR", f"Authentication failed: {response.status_code}")
                return False
        except Exception as e:
            self.log("ERROR", f"Authentication error: {e}")
            return False

    def create_test_user(self) -> Tuple[Optional[str], Optional[str], Optional[str]]:
        """Create a test user for IDOR testing."""
        timestamp = int(time.time())
        email = f"pentest_{timestamp}@test.com"
        password = f"Test{timestamp}!Abc"

        try:
            response = self.session.post(
                f"{TARGET_API}/auth/register",
                json={
                    "email": email,
                    "username": f"pentest_{timestamp}",
                    "display_name": f"Pentest User {timestamp}",
                    "password": password
                },
                timeout=10
            )

            if response.status_code == 200:
                # Login to get token
                login_resp = self.session.post(
                    f"{TARGET_API}/auth/login",
                    data={"username": email, "password": password},
                    timeout=10
                )
                if login_resp.status_code == 200:
                    token = login_resp.json().get("access_token")
                    return email, password, token
            return None, None, None
        except Exception as e:
            self.log("WARNING", f"Could not create test user: {e}")
            return None, None, None

    # =========================================================================
    # XSS VULNERABILITY TESTS (Previous HIGH findings)
    # =========================================================================

    def test_xss_in_ideas(self):
        """
        Retest: OCV-2024-2176 through OCV-2024-2180
        Previous finding: Potential stored XSS in ideas
        """
        self.log("INFO", "=" * 60)
        self.log("INFO", "Testing XSS vulnerabilities in ideas (OCV-2024-2176 to 2180)")
        self.log("INFO", "=" * 60)

        xss_found = False

        for i, payload in enumerate(XSS_PAYLOADS[:5]):
            finding_id = f"OCV-2024-217{6 + i}"

            try:
                response = self.session.post(
                    f"{TARGET_API}/ideas/",
                    headers={
                        "Authorization": f"Bearer {self.token}",
                        "Content-Type": "application/json"
                    },
                    json={
                        "title": f"XSS Retest {payload}",
                        "description": f"Testing: {payload}",
                        "category_id": 1,
                        "tags": []
                    },
                    timeout=10
                )

                if response.status_code == 200:
                    idea = response.json()

                    # Check if payload is stored as-is (vulnerability)
                    if payload in idea.get("title", "") or payload in idea.get("description", ""):
                        self.log("HIGH", f"XSS STILL VULNERABLE: Payload stored unsanitized",
                                finding_id=finding_id, status="STILL_VULNERABLE",
                                evidence=f"Payload: {payload[:50]}... stored in idea ID {idea.get('id')}")
                        xss_found = True
                    else:
                        self.log("INFO", f"XSS FIXED: Payload sanitized or rejected",
                                finding_id=finding_id, status="FIXED",
                                evidence=f"Payload was sanitized in response")

                    # Clean up - delete the test idea
                    self.session.delete(
                        f"{TARGET_API}/ideas/{idea['id']}",
                        headers={"Authorization": f"Bearer {self.token}"}
                    )

                elif response.status_code == 422:
                    self.log("INFO", f"XSS FIXED: Payload rejected by validation",
                            finding_id=finding_id, status="FIXED",
                            evidence=f"HTTP 422 - Validation rejected payload")
                else:
                    self.log("WARNING", f"Unexpected response: {response.status_code}",
                            finding_id=finding_id, status="INCONCLUSIVE",
                            evidence=f"HTTP {response.status_code}: {response.text[:100]}")

            except Exception as e:
                self.log("ERROR", f"Test failed: {e}",
                        finding_id=finding_id, status="INCONCLUSIVE")

        return not xss_found

    def test_xss_in_comments(self):
        """Test XSS in comment creation."""
        self.log("INFO", "Testing XSS in comments...")

        # Get an idea to comment on
        try:
            ideas = self.session.get(
                f"{TARGET_API}/ideas/leaderboard?limit=1",
                timeout=10
            ).json()

            if not ideas:
                self.log("WARNING", "No ideas available for comment testing")
                return True

            idea_id = ideas[0]["id"]
            xss_found = False

            for payload in XSS_PAYLOADS[:3]:
                response = self.session.post(
                    f"{TARGET_API}/comments/{idea_id}",
                    headers={
                        "Authorization": f"Bearer {self.token}",
                        "Content-Type": "application/json"
                    },
                    json={"content": payload},
                    timeout=10
                )

                if response.status_code in [200, 202]:
                    comment = response.json() if response.status_code == 200 else {}
                    if payload in str(comment):
                        self.log("HIGH", f"XSS in comments: Payload stored unsanitized",
                                status="STILL_VULNERABLE", evidence=f"Payload: {payload[:30]}...")
                        xss_found = True
                    else:
                        self.log("INFO", "Comment XSS: Payload sanitized (FIXED)")
                elif response.status_code == 422:
                    self.log("INFO", "Comment XSS: Payload rejected by validation (FIXED)")

            return not xss_found

        except Exception as e:
            self.log("ERROR", f"Comment XSS test failed: {e}")
            return True

    # =========================================================================
    # JWT SECURITY TESTS
    # =========================================================================

    def decode_token(self, token: str) -> Optional[Dict]:
        """Decode JWT without verification."""
        try:
            parts = token.split(".")
            if len(parts) != 3:
                return None

            header = json.loads(base64.urlsafe_b64decode(parts[0] + "=="))
            payload = json.loads(base64.urlsafe_b64decode(parts[1] + "=="))

            return {
                "header": header,
                "payload": payload,
                "signature": parts[2]
            }
        except Exception:
            return None

    def test_jwt_algorithm_none(self):
        """Test for algorithm confusion with 'none' algorithm."""
        self.log("INFO", "=" * 60)
        self.log("INFO", "Testing JWT algorithm 'none' bypass")
        self.log("INFO", "=" * 60)

        decoded = self.decode_token(self.token)
        if not decoded:
            self.log("ERROR", "Could not decode token")
            return True

        # Create token with alg:none
        header = {"alg": "none", "typ": "JWT"}
        payload = decoded["payload"]

        header_b64 = base64.urlsafe_b64encode(
            json.dumps(header).encode()
        ).decode().rstrip("=")
        payload_b64 = base64.urlsafe_b64encode(
            json.dumps(payload).encode()
        ).decode().rstrip("=")

        none_tokens = [
            f"{header_b64}.{payload_b64}.",
            f"{header_b64}.{payload_b64}",
        ]

        for none_token in none_tokens:
            response = self.session.get(
                f"{TARGET_API}/auth/me",
                headers={"Authorization": f"Bearer {none_token}"},
                timeout=10
            )

            if response.status_code == 200:
                self.log("CRITICAL", "JWT algorithm 'none' bypass SUCCESSFUL!",
                        status="STILL_VULNERABLE",
                        evidence=f"Token with alg:none accepted")
                return False

        self.log("INFO", "JWT algorithm 'none' bypass: FIXED (rejected)",
                status="FIXED")
        return True

    def test_jwt_weak_secrets(self):
        """Test for weak signing secrets."""
        self.log("INFO", "Testing for weak JWT secrets...")

        decoded = self.decode_token(self.token)
        if not decoded:
            return True

        vulnerable_secrets = []

        for secret in WEAK_SECRETS:
            header_b64 = base64.urlsafe_b64encode(
                json.dumps(decoded["header"]).encode()
            ).decode().rstrip("=")
            payload_b64 = base64.urlsafe_b64encode(
                json.dumps(decoded["payload"]).encode()
            ).decode().rstrip("=")

            message = f"{header_b64}.{payload_b64}"

            signature = hmac.new(
                secret.encode(),
                message.encode(),
                hashlib.sha256
            ).digest()
            signature_b64 = base64.urlsafe_b64encode(signature).decode().rstrip("=")

            forged_token = f"{message}.{signature_b64}"

            try:
                response = self.session.get(
                    f"{TARGET_API}/auth/me",
                    headers={"Authorization": f"Bearer {forged_token}"},
                    timeout=10
                )

                if response.status_code == 200:
                    self.log("CRITICAL", f"Weak JWT secret found: '{secret}'",
                            status="STILL_VULNERABLE",
                            evidence=f"Token signed with '{secret}' accepted")
                    vulnerable_secrets.append(secret)
            except Exception:
                pass

        if not vulnerable_secrets:
            self.log("INFO", "JWT weak secrets: FIXED (no weak secrets found)",
                    status="FIXED")
            return True
        return False

    def test_jwt_signature_validation(self):
        """Test if signature is properly validated."""
        self.log("INFO", "Testing JWT signature validation...")

        decoded = self.decode_token(self.token)
        if not decoded:
            return True

        header_b64 = base64.urlsafe_b64encode(
            json.dumps(decoded["header"]).encode()
        ).decode().rstrip("=")
        payload_b64 = base64.urlsafe_b64encode(
            json.dumps(decoded["payload"]).encode()
        ).decode().rstrip("=")

        # Test tokens with modified/stripped signatures
        test_tokens = [
            f"{header_b64}.{payload_b64}.",  # Empty signature
            f"{header_b64}.{payload_b64}.invalid",  # Invalid signature
            f"{self.token[:-10]}",  # Truncated token
        ]

        for test_token in test_tokens:
            try:
                response = self.session.get(
                    f"{TARGET_API}/auth/me",
                    headers={"Authorization": f"Bearer {test_token}"},
                    timeout=10
                )

                if response.status_code == 200:
                    self.log("CRITICAL", "Invalid JWT signature accepted!",
                            status="STILL_VULNERABLE",
                            evidence=f"Token: {test_token[:50]}...")
                    return False
            except Exception:
                pass

        self.log("INFO", "JWT signature validation: FIXED (invalid signatures rejected)",
                status="FIXED")
        return True

    # =========================================================================
    # AUTHENTICATION TESTS
    # =========================================================================

    def test_rate_limiting(self):
        """Test brute force protection on login."""
        self.log("INFO", "=" * 60)
        self.log("INFO", "Testing rate limiting on login endpoint")
        self.log("INFO", "=" * 60)

        failed_attempts = 0
        rate_limited = False

        for i in range(20):
            response = self.session.post(
                f"{TARGET_API}/auth/login",
                data={"username": "test@test.com", "password": f"wrong{i}"},
                timeout=10
            )

            if response.status_code == 429:
                rate_limited = True
                self.log("INFO", f"Rate limited after {i + 1} attempts (FIXED)",
                        status="FIXED",
                        evidence=f"HTTP 429 after {i + 1} attempts")
                break
            elif response.status_code == 401:
                failed_attempts += 1

            time.sleep(0.05)  # Small delay

        if not rate_limited and failed_attempts >= 20:
            self.log("HIGH", "No rate limiting detected on login endpoint!",
                    status="STILL_VULNERABLE",
                    evidence=f"20+ failed login attempts allowed without rate limiting")
            return False

        return True

    def test_account_enumeration(self):
        """Test for account enumeration via different responses."""
        self.log("INFO", "Testing for account enumeration...")

        # Test with existing user
        response_existing = self.session.post(
            f"{TARGET_API}/auth/login",
            data={"username": ADMIN_EMAIL, "password": "wrongpassword"},
            timeout=10
        )

        # Test with non-existing user
        response_nonexisting = self.session.post(
            f"{TARGET_API}/auth/login",
            data={"username": "nonexistent@test.com", "password": "wrongpassword"},
            timeout=10
        )

        # Compare responses
        if response_existing.text != response_nonexisting.text:
            self.log("MEDIUM", "Possible account enumeration - different responses",
                    status="STILL_VULNERABLE",
                    evidence=f"Different error messages for existing vs non-existing users")
            return False

        self.log("INFO", "Account enumeration: FIXED (identical error messages)",
                status="FIXED")
        return True

    # =========================================================================
    # IDOR TESTS
    # =========================================================================

    def test_admin_endpoint_access(self):
        """Test access control on admin endpoints."""
        self.log("INFO", "=" * 60)
        self.log("INFO", "Testing admin endpoint access control")
        self.log("INFO", "=" * 60)

        admin_endpoints = [
            "/admin/ideas/pending",
            "/admin/users",
            "/admin/analytics/overview",
        ]

        # Create a regular test user
        test_email, test_password, test_token = self.create_test_user()

        all_protected = True

        for endpoint in admin_endpoints:
            # Test without auth
            try:
                response = self.session.get(
                    f"{TARGET_API}{endpoint}",
                    timeout=10
                )

                if response.status_code == 200:
                    self.log("CRITICAL", f"Admin endpoint accessible without auth: {endpoint}",
                            status="STILL_VULNERABLE",
                            evidence=f"HTTP 200 without authentication")
                    all_protected = False
                elif response.status_code in [401, 403]:
                    self.log("INFO", f"Admin endpoint protected (no auth): {endpoint}",
                            status="FIXED")
            except Exception as e:
                self.log("WARNING", f"Could not test {endpoint}: {e}")

            # Test with regular user auth
            if test_token:
                try:
                    response = self.session.get(
                        f"{TARGET_API}{endpoint}",
                        headers={"Authorization": f"Bearer {test_token}"},
                        timeout=10
                    )

                    if response.status_code == 200:
                        self.log("CRITICAL", f"Admin endpoint accessible by regular user: {endpoint}",
                                status="STILL_VULNERABLE",
                                evidence=f"HTTP 200 with regular user token")
                        all_protected = False
                    elif response.status_code in [401, 403]:
                        self.log("INFO", f"Admin endpoint protected (regular user): {endpoint}",
                                status="FIXED")
                except Exception as e:
                    self.log("WARNING", f"Could not test {endpoint} with user token: {e}")

        return all_protected

    def test_idea_idor(self):
        """Test IDOR on idea editing/deletion."""
        self.log("INFO", "Testing IDOR on ideas...")

        # Get an idea
        try:
            ideas = self.session.get(
                f"{TARGET_API}/ideas/leaderboard?limit=1",
                timeout=10
            ).json()

            if not ideas:
                self.log("WARNING", "No ideas available for IDOR testing")
                return True

            idea_id = ideas[0]["id"]

            # Create a test user and try to edit someone else's idea
            test_email, test_password, test_token = self.create_test_user()

            if test_token:
                response = self.session.put(
                    f"{TARGET_API}/ideas/{idea_id}",
                    headers={
                        "Authorization": f"Bearer {test_token}",
                        "Content-Type": "application/json"
                    },
                    json={"title": "IDOR Test - Unauthorized Edit"},
                    timeout=10
                )

                if response.status_code == 200:
                    self.log("CRITICAL", f"IDOR: Able to edit idea {idea_id} as different user!",
                            status="STILL_VULNERABLE",
                            evidence=f"HTTP 200 - unauthorized edit succeeded")
                    return False
                elif response.status_code in [403, 401]:
                    self.log("INFO", "IDOR protection: Cannot edit others' ideas (FIXED)",
                            status="FIXED")

            return True

        except Exception as e:
            self.log("ERROR", f"IDOR test failed: {e}")
            return True

    # =========================================================================
    # MAIN TEST RUNNER
    # =========================================================================

    def run_all_tests(self):
        """Run all remediation verification tests."""
        self.log("INFO", "=" * 70)
        self.log("INFO", "REMEDIATION VERIFICATION TESTING")
        self.log("INFO", f"Target: {TARGET_API}")
        self.log("INFO", f"Date: {datetime.now().isoformat()}")
        self.log("INFO", "=" * 70)

        # Authenticate
        if not self.authenticate():
            self.log("ERROR", "Cannot proceed without authentication")
            return

        results_summary = {}

        # Run XSS tests (Previous HIGH findings)
        results_summary["xss_ideas"] = self.test_xss_in_ideas()
        results_summary["xss_comments"] = self.test_xss_in_comments()

        # Run JWT tests
        results_summary["jwt_alg_none"] = self.test_jwt_algorithm_none()
        results_summary["jwt_weak_secrets"] = self.test_jwt_weak_secrets()
        results_summary["jwt_signature"] = self.test_jwt_signature_validation()

        # Run Authentication tests
        results_summary["rate_limiting"] = self.test_rate_limiting()
        results_summary["account_enumeration"] = self.test_account_enumeration()

        # Run IDOR tests
        results_summary["admin_endpoints"] = self.test_admin_endpoint_access()
        results_summary["idea_idor"] = self.test_idea_idor()

        # Generate summary
        self.log("INFO", "=" * 70)
        self.log("INFO", "REMEDIATION VERIFICATION SUMMARY")
        self.log("INFO", "=" * 70)

        fixed_count = sum(1 for v in results_summary.values() if v is True)
        vulnerable_count = sum(1 for v in results_summary.values() if v is False)

        for test_name, passed in results_summary.items():
            status = "FIXED" if passed else "STILL VULNERABLE"
            self.log("INFO", f"  {test_name}: {status}")

        self.log("INFO", "-" * 70)
        self.log("INFO", f"FIXED: {fixed_count}/{len(results_summary)}")
        self.log("INFO", f"STILL VULNERABLE: {vulnerable_count}/{len(results_summary)}")

        # Save results
        results_file = RESULTS_DIR / "remediation_verification.json"
        with open(results_file, "w") as f:
            json.dump({
                "test_date": datetime.now().isoformat(),
                "target": TARGET_API,
                "summary": results_summary,
                "fixed_count": fixed_count,
                "vulnerable_count": vulnerable_count,
                "detailed_results": self.results
            }, f, indent=2)

        self.log("INFO", f"Results saved to: {results_file}")

        return results_summary


if __name__ == "__main__":
    tester = RemediationTester()
    tester.run_all_tests()
