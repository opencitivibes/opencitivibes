#!/usr/bin/env python3
"""
Custom security pattern analyzer for OpenCitiVibes Python code.

Detects project-specific security anti-patterns beyond standard tools.
"""

import ast
import json
import os
import sys
from pathlib import Path
from dataclasses import dataclass, asdict
from typing import List, Optional

SOURCE_DIR = os.environ.get("SOURCE_DIR", "/app/source")
SCAN_DIR = os.environ.get("SCAN_DIR", "/app/results/custom")


@dataclass
class Finding:
    file: str
    line: int
    column: int
    severity: str
    rule_id: str
    message: str
    code_snippet: Optional[str] = None


class SecurityVisitor(ast.NodeVisitor):
    """AST visitor to detect security issues."""

    def __init__(self, filename: str, source_lines: List[str]):
        self.filename = filename
        self.source_lines = source_lines
        self.findings: List[Finding] = []

    def get_snippet(self, lineno: int) -> str:
        if 0 < lineno <= len(self.source_lines):
            return self.source_lines[lineno - 1].strip()
        return ""

    def visit_Call(self, node: ast.Call):
        # Check for direct database queries in routers
        if isinstance(node.func, ast.Attribute):
            if node.func.attr in ("query", "execute") and "router" in self.filename:
                self.findings.append(Finding(
                    file=self.filename,
                    line=node.lineno,
                    column=node.col_offset,
                    severity="MEDIUM",
                    rule_id="OCV-001",
                    message="Direct database query in router - use service layer",
                    code_snippet=self.get_snippet(node.lineno)
                ))

            # Check for filter with user input
            if node.func.attr == "filter":
                for arg in node.args:
                    if isinstance(arg, ast.Compare):
                        self.findings.append(Finding(
                            file=self.filename,
                            line=node.lineno,
                            column=node.col_offset,
                            severity="INFO",
                            rule_id="OCV-002",
                            message="SQLAlchemy filter - verify user input is validated",
                            code_snippet=self.get_snippet(node.lineno)
                        ))

        # Check for JWT operations
        if isinstance(node.func, ast.Attribute):
            if node.func.attr in ("encode", "decode") and "jwt" in self.filename.lower():
                # Check if algorithm is explicitly set
                has_algorithm = False
                for keyword in node.keywords:
                    if keyword.arg == "algorithms" or keyword.arg == "algorithm":
                        has_algorithm = True
                        break

                if not has_algorithm:
                    self.findings.append(Finding(
                        file=self.filename,
                        line=node.lineno,
                        column=node.col_offset,
                        severity="HIGH",
                        rule_id="OCV-003",
                        message="JWT operation without explicit algorithm specification",
                        code_snippet=self.get_snippet(node.lineno)
                    ))

        self.generic_visit(node)

    def visit_FunctionDef(self, node: ast.FunctionDef):
        # Check for missing authentication in endpoint handlers
        if "router" in self.filename:
            has_auth = False
            for decorator in node.decorator_list:
                if isinstance(decorator, ast.Call):
                    # Check for router decorators
                    pass

            # Check function arguments for Depends(get_current_user)
            for arg in node.args.args:
                if arg.annotation:
                    if isinstance(arg.annotation, ast.Subscript):
                        # Could be Optional[User] or similar
                        pass

            for default in node.args.defaults:
                if isinstance(default, ast.Call):
                    if isinstance(default.func, ast.Name) and default.func.id == "Depends":
                        if default.args:
                            if isinstance(default.args[0], ast.Name):
                                if "user" in default.args[0].id.lower() or "auth" in default.args[0].id.lower():
                                    has_auth = True

        self.generic_visit(node)

    def visit_Assign(self, node: ast.Assign):
        # Check for hardcoded secrets
        for target in node.targets:
            if isinstance(target, ast.Name):
                if any(keyword in target.id.lower() for keyword in ["secret", "password", "key", "token"]):
                    if isinstance(node.value, ast.Constant) and isinstance(node.value.value, str):
                        if len(node.value.value) > 5:  # Not empty or very short
                            self.findings.append(Finding(
                                file=self.filename,
                                line=node.lineno,
                                column=node.col_offset,
                                severity="HIGH",
                                rule_id="OCV-004",
                                message=f"Potential hardcoded secret in variable '{target.id}'",
                                code_snippet=self.get_snippet(node.lineno)
                            ))

        self.generic_visit(node)


def analyze_file(filepath: Path) -> List[Finding]:
    """Analyze a single Python file."""
    try:
        with open(filepath, "r", encoding="utf-8") as f:
            source = f.read()
            source_lines = source.split("\n")

        tree = ast.parse(source, filename=str(filepath))
        visitor = SecurityVisitor(str(filepath), source_lines)
        visitor.visit(tree)
        return visitor.findings
    except Exception as e:
        print(f"Error analyzing {filepath}: {e}", file=sys.stderr)
        return []


def main():
    """Main function to run the analyzer."""
    backend_dir = Path(SOURCE_DIR) / "backend"
    output_dir = Path(SCAN_DIR)
    output_dir.mkdir(parents=True, exist_ok=True)

    all_findings: List[Finding] = []

    # Find all Python files
    python_files = list(backend_dir.rglob("*.py"))
    python_files = [f for f in python_files if ".venv" not in str(f) and "__pycache__" not in str(f)]

    print(f"Analyzing {len(python_files)} Python files...")

    for filepath in python_files:
        findings = analyze_file(filepath)
        all_findings.extend(findings)

    # Save results
    results = {
        "total_findings": len(all_findings),
        "by_severity": {
            "HIGH": len([f for f in all_findings if f.severity == "HIGH"]),
            "MEDIUM": len([f for f in all_findings if f.severity == "MEDIUM"]),
            "LOW": len([f for f in all_findings if f.severity == "LOW"]),
            "INFO": len([f for f in all_findings if f.severity == "INFO"]),
        },
        "findings": [asdict(f) for f in all_findings]
    }

    output_file = output_dir / "custom-python-analysis.json"
    with open(output_file, "w") as f:
        json.dump(results, f, indent=2)

    print(f"\nAnalysis complete!")
    print(f"Total findings: {len(all_findings)}")
    print(f"  HIGH: {results['by_severity']['HIGH']}")
    print(f"  MEDIUM: {results['by_severity']['MEDIUM']}")
    print(f"  LOW: {results['by_severity']['LOW']}")
    print(f"  INFO: {results['by_severity']['INFO']}")
    print(f"\nResults saved to: {output_file}")


if __name__ == "__main__":
    main()
